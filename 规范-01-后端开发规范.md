# 后端开发规范

## 一、 技术栈要求 (后端)
- 后端框架：Spring Boot + mybatis-plus + jwt + feign
- 数据库：MySQL 5.7+
- 缓存：Redis 6.0+
- 验证码服务：邮件验证码服务, 短信验证码服务
- API 接口：RESTful API

## 二、 架构设计规范

### 1. 分层架构
项目采用模块化分层架构，明确各模块职责，禁止循环依赖。

### 2. 模块划分与职责
| 模块名 | 职责 | 路径示例 |
|--------|------|----------|
| **common-module** | 全局常量、工具类、异常处理、统一响应对象、AOP 切面。 | `common-module/src/main/java/{{PACKAGE_BASE}}/common` |
| **dal-module** | 数据库实体 (Entity)、Mapper 接口、XML、DAL Service。仅暴露 DAL Service。 | `dal-module/src/main/java/{{PACKAGE_BASE}}/dal` |
| **third-party-module** | 集成外部服务 (短信、支付等)，隐藏具体供应商实现。 | `third-party-module/src/main/java/{{PACKAGE_BASE}}/thirdparty` |
| **admin-xxx-module** | B端业务模块，面向管理员，接口路径前缀 `/admin/`。 | `admin-account-module/...` |
| **frontend-xxx-module** | C端业务模块，面向消费者，接口路径前缀 `/api/`。 | `frontend-user-module/...` |
| **hub-module** | 统一三方回调入口，使用适配器模式处理不同平台数据。 | `hub-module/...` |
| **task-module** | 定时任务、MQ 消费者、异步任务。 | `task-module/...` |

### 3. Hub 三方回调模块模板代码
- **职责**：接收第三方系统的回调通知，使用统一接口 + 适配器模式处理。
- **适配器接口定义**：
```java
public interface HubAdapter {
    String eventType(); // pay, logistics, sms
    String platform();  // wechat, alipay, sf
    
    // 解析原始报文为统一结构
    HubCallbackData parse(String tenantId, String eventType, String platform, Map<String, String> queryParams, String rawData);
    
    // 构建返回给第三方的响应（String/XML/JSON等）
    Object buildCallbackData(String tenantId, String eventType, String platform, HubCallbackData data);
}

@Data
@Builder
public class HubCallbackData implements Serializable {
    private String tenantId;
    private String eventType;
    private String platform;
    private Map<String, Object> data;
    private LocalDateTime callbackTime;
    private boolean success;
    private String errorMsg;
}
```
- **统一 Controller 实现**：
```java
@Slf4j
@RestController
@RequestMapping("/hub")
public class HubController {
    private final ApplicationEventPublisher eventPublisher;
    private final HubAdapterFactory hubAdapterFactory;

    @PostMapping("/{eventType}/{platform}/{tenantId}")
    public Object callback(
            @PathVariable String eventType,
            @PathVariable String platform,
            @PathVariable String tenantId,
            @RequestParam Map<String, String> queryParams,
            @RequestBody String rawData) {
        log.info("callback[{}][{}][{}] params={}", eventType, platform, tenantId, JSON.toJSONString(queryParams));
        
        HubAdapter adapter = hubAdapterFactory.getAdapter(eventType, platform);
        if (adapter == null) return "adapter not found";
        
        try {
            HubCallbackData result = adapter.parse(tenantId, eventType, platform, queryParams, rawData);
            eventPublisher.publishEvent(new HubCallbackEvent(result)); // 抛出业务事件
            return adapter.buildCallbackData(tenantId, eventType, platform, result);
        } catch (Exception e) {
            log.error("callback error", e);
            return adapter.buildCallbackData(tenantId, eventType, platform, HubCallbackData.builder().success(false).build());
        }
    }
}
```
- **适配器工厂**：
```java
@Component
public class HubAdapterFactory {
    private final Map<String, HubAdapter> adapters = new ConcurrentHashMap<>();
    @Autowired
    private List<HubAdapter> adapterList;

    @PostConstruct
    public void init() {
        adapterList.forEach(a -> adapters.put(a.eventType() + ":" + a.platform(), a));
    }
    public HubAdapter getAdapter(String bizType, String platform) {
        return adapters.get(bizType + ":" + platform);
    }
}
```

## 三、 日志打印规范与格式

### 1. 核心要求
- **工具**：必须使用 SLF4J 接口 (`@Slf4j`)。禁止使用 `System.out` 或 `e.printStackTrace()`。
- **分层要求**：
    - **Service 入口**：必须打印类名、方法名及入参。
    - **Service 出口**：建议打印关键返回结果。
    - **异常捕获**：必须打印完整堆栈。

### 2. 日志格式示例
- **入参打印**：
  `log.info("Method started: class={}, method={}, params={}", getClass().getSimpleName(), "createUser", JSON.toJSONString(req));`
- **异常打印**：
  `log.error("Method failed: class={}, method={}, error={}", getClass().getSimpleName(), "createUser", e.getMessage(), e);`

### 3. 敏感信息脱敏
- 在打印日志（尤其是 JSON 序列化）时，必须对手机号、身份证、密码等敏感字段进行脱敏处理。建议使用 `Fastjson` 过滤器或自定义脱敏注解。

## 四、 外部服务集成与 Feign 日志

### 1. 统一请求链 (IApiService)
集成第三方服务时，必须遵循以下接口定义：
```java
public interface IApiService {
    <Resp extends ApiResponse> Resp request(ApiRequest<Resp> request) throws ApiException;
}

public interface ApiRequest<T extends ApiResponse> extends Serializable {
    String requestMappingUrl(); // 请求路径
    Class<T> respClass();       // 响应类
    default boolean ciphertextEnable() { return false; } // 是否加密
}

public interface ApiResponse extends Serializable {}
```

### 2. Feign CURL 日志规范
- **强制要求**：所有 Feign 客户端必须配置 `FeignLogger`，将请求格式化为 **多行 CURL 命令**。
- **日志级别**：必须设为 `Logger.Level.FULL`。
- **输出示例**：
```bash
FEIGN_REQ -> curl -X POST 'https://api.sms.com/v1/send' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer token123' \
  -d '{
    "phone": "13800138000",
    "content": "验证码：1234"
  }'
```
- **响应日志**：必须包含状态码和耗时。
  `FEIGN_RESP -> curl -X POST '...' [status:200] (150ms) body: {"code":0,"msg":"ok"}`

## 五、 命名与设计规范 (略)
*(详见：命名规范对照表、Redis Key 规范、事务与并发控制等内容...)*

## 六、 代码模板 (AI 生成基准)

### 1. 统一响应对象 (`Result<T>`)
```java
@Data
public class Result<T> implements Serializable {
    private String code;
    private String msg;
    private T data;
    public static <T> Result<T> success(T data) { ... }
    public static <T> Result<T> error(String code, String msg) { ... }
}
```

### 2. 基础实体 (`BaseEntity`)
```java
@Data
public abstract class BaseEntity implements Serializable {
    @TableId(type = IdType.AUTO)
    private Long id;
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime lastModifiedTime;
    @TableLogic
    private Integer isDeleted;
}
```
*(更多内容请参考 [规范-00-全局定义.md](./规范-00-全局定义.md))*
