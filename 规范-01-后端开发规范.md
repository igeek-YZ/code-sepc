# 后端开发规范

- 关联文档：
  - [规范-00-全局定义.md](规范-00-全局定义.md)
  - [规范-02-前端开发规范.md](规范-02-前端开发规范.md)
  - [规范-03-数据库设计规范.md](规范-03-数据库设计规范.md)

## 0、AI 生成协议（唯一依据，禁止猜测）

- 适用范围：Spring Boot + MyBatis-Plus + JWT + Feign（技术栈来自 [规范-00-全局定义.md](规范-00-全局定义.md)）。
- 唯一目标：让 AI 在生成后端代码时 **无偏移、无幻觉、无猜测**。

### 0.1 禁止猜测规则（硬性）

- AI 只能使用以下输入来源生成代码：
  - 本仓库规范文档（含本文件）
  - [规范-API接口定义.md](规范-API接口定义.md) 中已锁定的接口契约（字段/类型/路径/示例）
- 任何字段/类型/枚举值/表名/Redis Key/错误码 **只要未在规范或接口契约中出现**：
  - AI 必须输出“缺失信息清单”（字段名、类型、是否必填、来源模块），并停止生成，不允许用 `xxx`/`TODO`/`可能是`/`猜测` 填充。
- AI 输出代码必须可编译、可运行：
  - 禁止在最终代码中输出 `...`、`待补充`、`自行实现` 等占位符（本文档示例出现 `...` 仅表示“省略”，不得原样复制到代码）。
  - 允许使用本仓库的全局变量占位符（如 `{{PACKAGE_BASE}}`、`{{TABLE_PREFIX}}`），但最终落地代码必须替换为真实值。

### 0.2 后端统一约束（硬性）

- **统一返回结构**：所有 Controller 只能返回 `Result<T>`。
  - 成功码：`"200"`（字符串）
  - 失败码：业务错误码（字符串），禁止使用 HTTP 状态码充当业务错误码
- **错误码格式**：`{模块码}{类型码}{序号}`，固定 6 位数字字符串：
  - 模块码：2 位（如 00 公共、10 用户、20 商品…）
  - 类型码：2 位（01-09 参数校验、10-19 数据不存在、20-29 状态异常、30-39 规则冲突、40-49 权限不足、50-59 认证失败、90-99 系统错误）
  - 序号：2 位（00-99）
- **异常处理**：
  - Service 层遇到业务失败必须抛 `BusinessException`（携带 `code` 与 `message`）
  - Controller 层禁止 try-catch 业务异常（必须交给全局异常处理）
- **分层调用**（唯一允许的调用链）：
  - Controller → Biz Service → DAL Service → Mapper
  - Biz Service → Third-party Service（Feign/SDK）
  - 禁止 Biz Service 直接调用 Mapper
- **事务**：只允许加在 Service 方法上，且必须使用 `@Transactional(rollbackFor = Exception.class)`。
- **并发控制**：
  - 涉及资金/库存/状态流转的写操作：必须使用 Redisson 分布式锁或“条件更新（状态机）”实现幂等与并发安全。
- **表名与主键**：
  - Entity 的 `@TableName` 必须使用全局表前缀：`"{{TABLE_PREFIX}}{entity}"`（`{entity}` 为不含前缀的 snake_case）。
  - 主键 ID 必须使用雪花 ID（MyBatis-Plus `IdType.ASSIGN_ID`），禁止 `AUTO_INCREMENT`。

### 0.3 AI 生成输出清单（硬性）

- 每次生成一个业务能力，AI 必须先输出并确认：
  - 接口清单：路径、方法、入参 DTO、出参 VO、错误码列表
  - 数据清单：涉及的表名（含 `{{TABLE_PREFIX}}`）、字段列表与类型
  - Redis 清单：Key 名称、Key 模板、过期时间、读写位置
  - 事件清单：事件类名、发布点、监听器、是否异步
- AI 再输出代码文件清单（新增/修改），最后输出完整代码。

### 0.4 后端必备类（必须先存在，且全项目唯一）

- `common-module` 必须包含以下“全局唯一”类（禁止在业务模块重复定义）：
  - `Result<T>`：统一响应对象（成功码必须为 `"200"`，失败码必须为 6 位业务错误码字符串）
  - `BizCodeEnum`：全局错误码枚举（至少包含 `UNKNOWN_ERROR=009000`、`PARAM_VALID_ERROR=000100`）
  - `BusinessException`：业务异常（必须携带 `code`，并将 `message` 传递给 `RuntimeException`）
  - `GlobalExceptionHandler`：全局异常处理（只在此处将异常转为 `Result`）

- **BizCodeEnum 模板（common-module）**：
  ```java
  @Getter
  public enum BizCodeEnum {
      UNKNOWN_ERROR("009000", "系统未知错误"),
      PARAM_VALID_ERROR("000100", "参数校验失败"),
      ;
  
      private final String code;
      private final String message;
  
      BizCodeEnum(String code, String message) {
          this.code = code;
          this.message = message;
      }
  }
  ```

- **BusinessException 模板（common-module）**：
  ```java
  @Getter
  public class BusinessException extends RuntimeException {
      private final String code;
  
      public BusinessException(BizCodeEnum bizCode) {
          super(bizCode.getMessage());
          this.code = bizCode.getCode();
      }
  
      public BusinessException(String code, String message) {
          super(message);
          this.code = code;
      }
  }
  ```

- **GlobalExceptionHandler 模板（common-module）**：
  ```java
  @Slf4j
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(BusinessException.class)
      public Result<Void> handleBusinessException(BusinessException e) {
          return Result.error(e.getCode(), e.getMessage());
      }
  
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public Result<Void> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
          FieldError fieldError = e.getBindingResult().getFieldError();
          String message = fieldError == null ? "参数校验失败" : fieldError.getDefaultMessage();
          return Result.error("000100", "参数校验失败: " + message);
      }
  
      @ExceptionHandler(Exception.class)
      public Result<Void> handleException(Exception e) {
          log.error("system error: {}", e.getMessage(), e);
          return Result.error("009000", "系统繁忙，请稍后重试");
      }
  }
  ```

- **架构设计规范**：
  - **分层架构**：项目采用模块化分层架构，明确各模块职责，禁止循环依赖。
  - **模块划分**：
    1.  **common-module (公共组件模块)**：
        - 包含全局常量、工具类 (Utils)、全局异常处理 (GlobalExceptionHandler)、统一响应对象 (Result)、AOP 切面 (日志/权限) 等。
        - 被所有其他模块依赖。
        - 路径：`common-module/src/main/java/{{PACKAGE_BASE}}/common`
    2.  **dal-module (数据访问层模块)**：
        - **职责**：负责所有与数据库交互的逻辑。
        - **包含内容**：Entity (实体类)、Mapper (MyBatis接口)、XML 映射文件、DAL Service (对 Mapper 的简单封装，提供原子性的 CRUD 操作)。
        - **对外暴露**：仅暴露 DAL Service 接口，屏蔽底层数据库实现细节。
        - **依赖**：依赖 common-module。
        - 路径：`dal-module/src/main/java/{{PACKAGE_BASE}}/dal`
    3.  **third-party-module (第三方服务模块)**：
        - **职责**：集成外部服务 (如短信、邮件、文件存储、支付等)。
        - **包含内容**：Feign Client、SDK 集成代码、适配器模式实现的 Service。
        - **对外暴露**：统一的 Service 接口 (如 `SmsService`)，隐藏具体供应商实现。
        - **依赖**：依赖 common-module。
        - 路径：`third-party-module/src/main/java/{{PACKAGE_BASE}}/thirdparty`
    4.  **业务模块 (biz-xxx-module)**：
        - **职责**：核心业务逻辑实现，按领域划分为独立子模块。
        - **模块列表**：
          | 模块名 | 领域 | 职责 | 路径 |
          |--------|------|------|------|
          | admin-account-module | 账号模块 | 用户登录、注册、认证、Token管理、权限控制 | `admin-account-module/...` |
          | admin-user-module | 用户模块 | 用户信息管理、会员等级、地址管理 | `admin-user-module/...` |
          | admin-product-module | 商品模块 | 商品发布、类目管理、商品详情、商品评价 | `admin-product-module/...` |
          | admin-price-module | 价格模块 | 商品定价、价格策略、成本价管理 | `admin-price-module/...` |
          | admin-inventory-module | 库存模块 | 库存管理、库存预警、库存日志 | `admin-inventory-module/...` |
          | admin-order-module | 订单模块 | 订单创建、支付、取消、关闭、发货、收货 | `admin-order-module/...` |
          | admin-aftersales-module | 售后单模块 | 退款、退货、换货、售后审核 | `admin-aftersales-module/...` |
          | admin-guide-module | 导购模块 | 导购员管理、导购业绩、导购跟踪 | `admin-guide-module/...` |
          | admin-promotion-module | 促销模块 | 优惠券、满减、秒杀、团购、拼团 | `admin-promotion-module/...` |
          | admin-marketing-module | 营销模块 | 活动管理、推荐算法、用户触达 | `admin-marketing-module/...` |
          | frontend-cart-module | 购物车模块 | 购物车CRUD、购物车合并 | `frontend-cart-module/...` |
          | frontend-order-module | 订单模块 | 订单创建、支付、取消、关闭、发货、收货 | `frontend-order-module/...` |
          | frontend-product-module | 商品模块 | 商品浏览、搜索、详情、评价 | `frontend-product-module/...` |
          | frontend-user-module | 用户模块 | 用户信息、收货地址 | `frontend-user-module/...` |
        - **端区分**：
          - **B端 (admin-xxx-module)**：面向商家/管理员的管理后台接口
            - Controller 路径：`/admin/{module}/`，如 `/admin/order/`, `/admin/product/`
            - 命名规范：`XxxAdminController`
          - **C端 (frontend-xxx-module)**：面向消费者的移动端/PC端接口
            - Controller 路径：`/api/{module}/`，如 `/api/order/`, `/api/cart/`
            - 命名规范：`XxxApiController`
          - **开放API (biz-open-api-module)**：面向第三方的开放接口
            - Controller 路径：`/open/{module}/`，如 `/open/order/`
            - 命名规范：`XxxOpenController`
        - **调用关系**：
          - Biz Service 调用 DAL Service 进行数据读写
          - Biz Service 调用 Third-party Service 使用外部能力
          - 禁止 Biz Service 直接调用 Mapper
        - **依赖**：依赖 common-module, dal-module, third-party-module
    5.  **hub-module (三方回调接口模块)**：
        - **职责**：接收第三方系统的回调通知，使用统一接口 + 适配器模式处理
        - **接口路径规则**：`/hub/{eventType}/{platform}/{tenantId}`
          | 参数 | 说明 | 示例 |
          |------|------|------|
          | `{eventType}` | 业务事件类型 | `pay`, `logistics`, `sms` |
          | `{platform}` | 平台标识 | `wechat`, `alipay`, `sf`, `yunpian` |
          | `{tenantId}` | 租户ID | `t_1001`, `tenant_001` |
        - **接口设计**：
          - 每个业务事件类型只保留 **一个统一接口**
          - 入参为 `String` 类型（原始报文），通过 `@RequestParam` 获取 Query 参数，`@RequestBody` 获取 Body 参数
          - 使用平台适配器解析为统一数据结构
          - 抛出租户业务事件，由业务模块处理
        - **接口示例**：
          | 业务类型 | 接口路径 | 用途 |
          |----------|----------|------|
          | 支付 | `/hub/pay/wechat/t_1001` | 微信支付回调 |
          | 支付 | `/hub/pay/alipay/t_1001` | 支付宝回调 |
          | 物流 | `/hub/logistics/sf/t_1001` | 顺丰物流回调 |
          | 短信 | `/hub/sms/yunpian/t_1001` | 云片短信回调 |
        - **适配器接口定义**：
          ```java
          public interface HubAdapter {
              /**
               * 获取业务事件类型
               */
              String eventType();
              
              /**
               * 获取适配器支持的平台
               */
              String platform();
              
              /**
               * 处理回调
               *
               * @param queryParams Query 参数 map
               * @param rawData 原始报文
               * @param tenantId 租户ID
               * @return 响应数据（String/XML/JSON等）
               */
              HubCallbackData parse(String tenantId, String eventType, String platform, Map<String, String> queryParams, String rawData);

              /**
               * 构建回调数据
               *
               * @param tenantId 租户ID
               * @param eventType 事件类型
               * @param platform 平台标识
               * @param data 回调数据
               * @return 响应数据（String/XML/JSON等）
               */
              Object buildCallbackData(String tenantId, String eventType, String platform, HubCallbackData data);
          }
          
          /**
           * 统一回调数据结构
           */
          @Data
          @Builder
          @NoArgsConstructor
          @AllArgsConstructor
          public class HubCallbackData implements Serializable {
              private String tenantId;
              private String eventType;
              private String platform;
              private Map<String, Object> data;
              private LocalDateTime callbackTime;
              private boolean success;
              private String errorMsg;
          }
          
          /**
           * 回调事件基类
           */
          @Data
          @AllArgsConstructor
          public class HubCallbackEvent {
              private HubCallbackData data;
          }
          ```
        - **统一 Controller 实现**：
          ```java
          @Slf4j
          @RestController
          @RequestMapping("/hub")
          public class HubController {
              private final ApplicationEventPublisher eventPublisher;
              private final HubAdapterFactory hubAdapterFactory;
              
              /**
               * 统一回调入口
               *
               * @param eventType 业务事件类型 (pay/logistics/sms)
               * @param platform  平台标识 (wechat/alipay/sf)
               * @param tenantId  租户ID
               * @param queryParams 所有 Query 参数
               * @param rawData   原始报文 (Request Body)
               * @return 响应
               */
              @PostMapping("/{eventType}/{platform}/{tenantId}")
              public Object callback(
                      @PathVariable String eventType,
                      @PathVariable String platform,
                      @PathVariable String tenantId,
                      @RequestParam Map<String, String> queryParams,
                      @RequestBody String rawData) {
                  log.info("callback[{}][{}][{}] queryParams={}", eventType, platform, tenantId, JSON.toJSONString(queryParams));
                  
                  // 1. 获取适配器
                  HubAdapter adapter = hubAdapterFactory.getAdapter(eventType, platform);
                  if (adapter == null) {
                      log.error("callback[{}][{}][{}] adapter not found", eventType, platform, tenantId);
                      return "adapter not found";
                  }
                  
                  try {
                      // 2. 处理回调，返回响应数据
                        HubCallbackData result = adapter.parse(tenantId, eventType, platform, queryParams, rawData);
                      
                      log.info("callback[{}][{}][{}] success", eventType, platform, tenantId);

                      eventPublisher.publishEvent(new HubCallbackEvent(result));
                      return adapter.buildCallbackData(tenantId, eventType, platform, result);
                      
                  } catch (Exception e) {
                      log.error("callback[{}][{}][{}] error: {}", eventType, platform, tenantId, e.getMessage(), e);
                      return adapter.buildCallbackData(tenantId, eventType, platform, HubCallbackData.builder()
                              .success(false)
                              .errorMsg(e.getMessage())
                              .build());
                  }
              } 
          }
          ```
        - **适配器工厂**：
          ```java
          @Component
          public class HubAdapterFactory {
              private final Map<String, HubAdapter> adapters = new ConcurrentHashMap<>();
              private final ApplicationContext applicationContext;
              
              public HubAdapterFactory(ApplicationContext applicationContext) {
                  this.applicationContext = applicationContext;
              }
              
              @PostConstruct
              public void init() {
                  Map<String, HubAdapter> beans = applicationContext.getBeansOfType(HubAdapter.class);
                  beans.values().forEach(adapter -> {
                      String key = adapter.eventType() + ":" + adapter.platform();
                      adapters.put(key, adapter);
                  });
              }
              
              public HubAdapter getAdapter(String eventType, String platform) {
                  return adapters.get(eventType + ":" + platform);
              }
          }
          ```
        - **强制要求**：
          - 每个业务类型只保留 **一个 Controller 接口**
          - 入参必须为 `String` 类型（原始报文）
          - 必须通过 `@RequestParam` 获取 Query 参数，`@RequestBody` 获取 Body
          - 必须使用适配器模式解析不同平台数据
          - 必须抛出租户业务事件（`HubCallbackEvent` 或业务特定事件）
          - 必须记录完整回调日志
          - 必须返回第三方要求的响应格式
        - **依赖**：依赖 common-module, third-party-module
    6.  **task-module (后台任务模块)**：
        - **职责**：定时任务、消息队列消费者、异步任务处理
        - **任务分类**：
          | 任务类型 | 命名规则 | 示例 |
          |----------|----------|------|
          | 定时任务 | `XxxScheduleTask` | `OrderTimeoutCloseScheduleTask` |
          | 消息消费者 | `XxxMqConsumer` | `OrderCreatedMqConsumer` |
          | 异步任务 | `XxxAsyncTask` | `InventorySyncAsyncTask` |
        - **任务存放路径**：`task-module/src/main/java/{{PACKAGE_BASE}}/task/{模块名}/`
          | 模块 | 路径 |
          |------|------|
          | 订单任务 | `task/order/` |
          | 库存任务 | `task/inventory/` |
          | 营销任务 | `task/marketing/` |
          | 结算任务 | `task/settlement/` |
          | 数据任务 | `task/data/` |
        - **依赖**：依赖 common-module, dal-module, admin-xxx-module, frontend-xxx-module
        - **强制要求**：
          - 所有任务必须实现幂等性
          - 必须配置合理的重试机制和失败告警
          - 必须记录任务执行日志

  - **工程目录结构示例**：
    ```text
    project-root
    ├── common-module
    │   └── src/main/java/{{PACKAGE_BASE}}/common
    │       ├── config      // 全局配置
    │       ├── constant    // 全局常量
    │       ├── exception   // 全局异常
    │       ├── model       // 统一对象
    │       └── utils       // 工具类
    ├── dal-module
    │   └── src/main/java/{{PACKAGE_BASE}}/dal
    │       ├── entity      // 数据库实体
    │       ├── mapper      // MyBatis 接口
    │       └── service     // DAL Service
    ├── third-party-module
    │   └── src/main/java/{{PACKAGE_BASE}}/thirdparty
    │       ├── client      // Feign 客户端
    │       └── service     // 适配服务实现
    ├── admin-account-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/account
    │       ├── controller  // 控制器
    │       │   └── admin   // B端 Controller (AccountAdminController)
    │       ├── service     // 业务逻辑层
    │       │   ├── AccountService
    │       │   └── AccountServiceImpl
    │       └── model       // 数据模型
    │           ├── dto
    │           └── vo
    ├── frontend-order-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/order
    │       ├── controller
    │       │   └── api     // C端 Controller (OrderApiController) -> /api/order/
    │       ├── service
    │       ├── model
    │       │   ├── dto
    │       │   └── vo
    │       └── enums       // 订单相关枚举
    ├── admin-product-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/product
    │       ├── controller
    │       │   └── admin   // B端 Controller (ProductAdminController) -> /admin/product/
    │       ├── service
    │       ├── model
    │       │   ├── dto
    │       │   └── vo
    │       └── enums
    ├── admin-inventory-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/inventory
    │       ├── controller
    │       │   └── admin   // B端 Controller (InventoryAdminController) -> /admin/inventory/
    │       ├── service
    │       └── model
    │           ├── dto
    │           └── vo
    ├── hub-module
    │   └── src/main/java/{{PACKAGE_BASE}}/hub
    │       ├── controller   // 统一回调入口 (HubController -> /hub/{eventType}/{platform}/{tenantId})
    │       ├── adapter      // 平台适配器
    │       │   ├── HubAdapter       // 适配器接口
    │       │   └── HubAdapterFactory // 适配器工厂
    │       ├── model        // 统一回调数据结构
    │       │   ├── HubCallbackData
    │       │   └── HubCallbackEvent
    │       └── event        // 业务事件（转发给业务模块）
    │           ├── PayCallbackEvent
    │           ├── LogisticsCallbackEvent
    │           └── SmsCallbackEvent
    ├── task-module
    │   └── src/main/java/{{PACKAGE_BASE}}/task
    │       ├── order       // 订单相关定时任务
    │       │   ├── OrderTimeoutCloseScheduleTask
    │       │   └── OrderSyncMqConsumer
    │       ├── inventory   // 库存相关任务
    │       │   └── InventorySyncScheduleTask
    │       ├── marketing   // 营销相关任务
    │       │   └── CouponExpireScheduleTask
    │       └── data        // 数据相关任务
    │           └── StatisticsScheduleTask
    └── ...
    ```

- **通用设计**：
  - **核心类骨架 (Skeleton Code)**：
    - **统一响应对象 (`Result<T>`)**：
      ```java
      @Data
      public class Result<T> implements Serializable {
          public static final String SUCCESS_CODE = "200";
          private String code;
          private String msg;
          private T data;
          
          public static Result<Void> success() {
              Result<Void> result = new Result<>();
              result.code = SUCCESS_CODE;
              result.msg = "success";
              return result;
          }
          
          public static <T> Result<T> success(T data) {
              Result<T> result = new Result<>();
              result.code = SUCCESS_CODE;
              result.msg = "success";
              result.data = data;
              return result;
          }
          
          public static <T> Result<T> error(String code, String msg) {
              Result<T> result = new Result<>();
              result.code = code;
              result.msg = msg;
              return result;
          }
      }
      ```
    - **数据库基础实体 (`BaseEntity`)**：
      ```java
      @Data
      public abstract class BaseEntity implements Serializable {
          @TableId(type = IdType.ASSIGN_ID)
          private Long id;
          
          @TableField("status")
          private Integer status;
          
          @TableLogic
          @TableField("is_deleted")
          private Integer isDeleted; // 0:未删, 1:已删
          
          @TableField(value = "create_time", fill = FieldFill.INSERT)
          private LocalDateTime createTime;
          
          @TableField(value = "last_modified_time", fill = FieldFill.INSERT_UPDATE)
          private LocalDateTime lastModifiedTime;
      }
      ```
  - **代码模块化设计**：每个模块负责特定的功能，抽象出模块 Service 对外提供方法便于扩展，模块之间解耦。
  - **Lombok 使用**：DTO/VO/Entity 统一使用 `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`。
  - **枚举与常量**：
    - 业务状态值必须定义 Enum，实现 `IEnum<Integer>` 接口（MyBatis-Plus）。
    - 常量类命名为 `XxxConst` (如 `RedisConst`), 字段使用 `public static final`。

  - **错误码规范**：
    - **命名格式**：`{模块码}{类型码}{序号}`，固定 6 位数字字符串（模块码2位 + 类型码2位 + 序号2位）。
    - **模块码定义**：
      | 模块 | 模块码 | 示例 |
      |------|--------|------|
      | 公共模块 | 00 | 009000 = 系统未知错误 |
      | 用户模块 | 10 | 101000 = 用户不存在, 102000 = 用户已禁用 |
      | 商品模块 | 20 | 201000 = 商品不存在, 202000 = 商品库存不足 |
      | 订单模块 | 30 | 301000 = 订单不存在, 302000 = 订单状态异常 |
      | 库存模块 | 40 | 401000 = 库存不足, 403000 = 库存服务繁忙 |
      | 支付模块 | 50 | 509000 = 支付失败, 503000 = 支付金额不匹配 |
      | 认证模块 | 60 | 605000 = Token无效, 605001 = Token已过期 |
      | 验证码模块 | 70 | 701000 = 验证码错误, 702000 = 验证码已过期 |
    - **类型码定义**：
      | 类型码范围 | 类型 | 说明 |
      |------------|------|------|
      | 01-09 | 参数校验错误 | 请求参数格式、必填、长度等校验失败 |
      | 10-19 | 数据不存在 | 查询的数据记录不存在 |
      | 20-29 | 状态异常 | 数据状态不满足操作条件（如订单已取消） |
      | 30-39 | 业务规则冲突 | 唯一性约束、业务规则校验失败 |
      | 40-49 | 权限不足 | 用户无权限执行该操作 |
      | 50-59 | 认证失败 | Token无效、登录失效等 |
      | 90-99 | 系统错误 | 内部异常、第三方服务调用失败等 |
    - **错误码示例**：
      ```java
      // ✅ 正确示例 - BizCodeEnum
      public enum BizCodeEnum {
          // 公共错误码 (00)
          UNKNOWN_ERROR("009000", "系统未知错误"),
          PARAM_VALID_ERROR("000100", "参数校验失败"),
          
          // 用户模块 (10)
          USER_NOT_FOUND("101000", "用户不存在"),
          USER_DISABLED("102000", "用户已被禁用"),
          USER_PHONE_EXISTS("103000", "手机号已被注册"),
          
          // 商品模块 (20)
          PRODUCT_NOT_FOUND("201000", "商品不存在"),
          PRODUCT_STOCK_INSUFFICIENT("202000", "商品库存不足"),
          
          // 订单模块 (30)
          ORDER_DUPLICATE_SUBMIT("303000", "请勿重复提交"),
          ORDER_STATUS_ERROR("302001", "订单状态不满足操作条件"),
          
          // 库存模块 (40)
          STOCK_BUSY("403000", "库存服务繁忙，请稍后重试"),
          
          // 认证模块 (60)
          TOKEN_INVALID("605000", "Token无效"),
          TOKEN_EXPIRED("605001", "Token已过期"),
          ;
          
          private final String code;
          private final String message;
          
          BizCodeEnum(String code, String message) {
              this.code = code;
              this.message = message;
          }
          
          public String getCode() { return code; }
          public String getMessage() { return message; }
      }
      
      // ✅ 正确示例 - BusinessException
      public class BusinessException extends RuntimeException {
          private String code;
          
          public BusinessException(BizCodeEnum bizCode) {
              super(bizCode.getMessage());
              this.code = bizCode.getCode();
          }
          
          public BusinessException(String code, String message) {
              super(message);
              this.code = code;
          }
          
          public String getCode() { return code; }
      }
      
      // ❌ 错误示例
      // 直接硬编码错误码
      throw new BusinessException("101000", "用户不存在");
      
      // 使用非标准格式的错误码
      throw new BusinessException("USER_NOT_FOUND", "用户不存在");
      ```
    - **错误码使用规范**：
      - 所有业务校验失败**必须**抛出 `BusinessException`，携带标准错误码。
      - 禁止直接硬编码错误码数字，必须通过 `BizCodeEnum` 统一管理。
      - 错误码一旦发布不可变更（保证前端错误码映射表稳定）。

  - **字段命名规范**：
    - **请求/响应字段**：统一使用 **camelCase**（小驼峰）。
      | 正例 | 反例 |
      |------|------|
      | `userName` | `user_name`, `UserName` |
      | `orderId` | `order_id`, `OrderId` |
      | `totalStock` | `total_stock`, `TotalStock` |
    - **数据库字段**：统一使用 **snake_case**（下划线分隔）。
      | 正例 | 反例 |
      |------|------|
      | `user_name` | `userName`, `UserName` |
      | `order_id` | `orderId`, `OrderId` |
      | `total_stock` | `totalStock`, `TotalStock` |
    - **枚举值**：统一使用 **UPPER_SNAKE_CASE**（大写下划线）。
      | 正例 | 反例 |
      |------|------|
      | `ORDER_STATUS_PENDING` | `ORDER_STATUS_PENDING`, `OrderStatusPending` |
      | `USER_TYPE_ADMIN` | `USER_TYPE_ADMIN`, `UserTypeAdmin` |
    - **映射规则**：
      - Entity 字段使用 `@TableField("user_name")` 映射数据库字段。
      - DTO/VO 字段直接使用 camelCase，与前端 JSON 保持一致。
      - 禁止在 DTO/VO 中使用 `@TableField` 注解（不映射数据库）。
    - **强制要求**：
      - API 接口的 JSON 请求/响应必须使用 camelCase。
      - 数据库表字段必须使用 snake_case。
      - 前后端联调时，字段名必须保持一致（camelCase）。

- **命名规范对照表**：
  - **类命名规则**：
    | 类型 | 命名规则 | 正例 | 反例 |
    |------|----------|------|------|
    | Entity | `XxxEntity` | `UserEntity`, `OrderEntity` | `User`, `UserDO` |
    | DTO 请求 | `XxxReq` / `XxxReqDTO` | `UserCreateReq`, `UserLoginReqDTO` | `UserDTO`, `UserInput` |
    | DTO 响应 | `XxxResp` / `XxxVO` | `UserResp`, `UserInfoVO` | `UserDTO`, `UserResult` |
    | Mapper | `XxxMapper` | `UserMapper` | `UserDAO`, `UserRepository` |
    | Mapper XML | `XxxMapper.xml` | `UserMapper.xml` | `UserDAO.xml` |
    | Service 接口 | `XxxService` | `UserService` | `UserBiz`, `UserManager` |
    | Service 实现 | `XxxServiceImpl` | `UserServiceImpl` | `UserService`, `UserBizImpl` |
    | Controller | `XxxController` | `UserController` | `UserAPI`, `UserAction` |
    | 异常类 | `XxxException` | `BusinessException` | `UserError`, `UserException` |
    | 常量类 | `XxxConst` | `RedisConst` | `RedisConstants`, `REDIS_KEY` |
    | 枚举类 | `XxxEnum` | `UserStatusEnum` | `UserStatus`, `UserStatusType` |
    | 事件类 | `XxxEvent` | `OrderCreatedEvent` | `OrderEvent`, `OrderCreateEvent` |
    | 监听类 | `XxxListener` | `OrderCreatedListener` | `OrderEventListener` |
    | 配置类 | `XxxConfig` | `RedisConfig` | `RedisConfiguration` |
  - **方法命名规则**：
    | 类型 | 命名规则 | 正例 | 反例 |
    |------|----------|------|------|
    | 查询单条 | `getXxxByXxx` | `getUserById(Long id)` | `findUser(id)`, `selectUser` |
    | 查询列表 | `listXxx` / `getXxxList` | `listUserByStatus(Integer status)` | `getUsers(status)` |
    | 分页查询 | `pageXxx` | `pageUser(UserQuery query)` | `getUserPage(query)` |
    | 游标分页 | `listXxxByCursor` | `listUserByCursor(UserQuery query, Long lastId, Integer limit)` | - |
    | 新增 | `createXxx` / `saveXxx` | `createUser(UserCreateReq req)` | `addUser(req)`, `insertUser(req)` |
    | 修改 | `updateXxx` | `updateUser(UserUpdateReq req)` | `modifyUser(req)`, `editUser(req)` |
    | 删除 | `deleteXxxByXxx` | `deleteUserById(Long id)` | `removeUser(id)`, `delUser(id)` |
    | 统计 | `countXxx` | `countUserByStatus(Integer status)` | `getUserCount(status)` |
    | 判断是否存在 | `existsXxxByXxx` | `existsUserByPhone(String phone)` | `checkUser(phone)`, `userExists(phone)` |
  - **变量命名规则**：
    - 普通变量：使用小驼峰 `userName`, `orderList`
    - 常量：全大写下划线 `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE`
    - 集合变量：使用复数形式 `userList`, `idList`
    - 布尔变量：以 `is`, `has`, `can` 开头 `isDeleted`, `hasPermission`, `canAccess`
    - 临时变量：使用泛化名称 `obj`, `entity`, `req`, `resp`
  
  - **包名命名规则**：
    | 包名 | 用途 | 示例 |
    |------|------|------|
    | `entity` | 数据库实体 | `com.example.dal.entity` |
    | `mapper` | MyBatis 接口 | `com.example.dal.mapper` |
    | `service` | 服务接口 | `com.example.biz.service` |
    | `service.impl` | 服务实现 | `com.example.biz.service.impl` |
    | `controller` | 控制器 | `com.example.biz.controller` |
    | `dto` | 请求/响应对象 | `com.example.biz.model.dto` |
    | `vo` | 视图对象 | `com.example.biz.model.vo` |
    | `enums` | 枚举类 | `com.example.common.enums` |
    | `constants` | 常量类 | `com.example.common.constants` |
    | `exception` | 异常类 | `com.example.common.exception` |
    | `config` | 配置类 | `com.example.common.config` |
    | `utils` | 工具类 | `com.example.common.utils` |
    | `client` | Feign 客户端 | `com.example.thirdparty.client` |
    | `listener` | 事件监听器 | `com.example.biz.listener` |
    | `event` | 事件类 | `com.example.biz.event` |

- **Redis Key 命名规范**：
  - **命名格式**：`{业务前缀}:{模块名}:{具体标识}`
  - **示例**：
    | 用途 | 命名规则 | 正例 |
    |------|----------|------|
    | 用户信息缓存 | `user:info:{userId}` | `user:info:1001` |
    | 用户Token | `user:token:{userId}` | `user:token:1001` |
    | 验证码 | `verify:code:{phone}` | `verify:code:13800138000` |
    | 分布式锁 | `lock:{biz}:{id}` | `lock:order:pay:1001` |
    | 幂等Key | `idempotent:{biz}:{uniqueKey}` | `idempotent:order:create:abc123` |
    | 分布式锁 | `{prefix}:lock:{biz}:{id}` | `app:lock:order:pay:1001` |
  - **强制要求**：
    - 所有 Key 必须定义在常量类中，禁止硬编码
    - 必须设置合理的过期时间
    - 禁止使用模糊匹配批量删除（使用 `SCAN` 命令替代）

- **日志规范**：
  - **工具选择**：必须使用 SLF4J 接口配合 Logback 实现。禁止使用 `System.out` 或 `e.printStackTrace()`。
  - **注解使用**：类上统一使用 Lombok 的 `@Slf4j` 注解。
  - **日志打印场景与格式**：
    - **Service 方法入口**：
      - 必须打印。
      - 格式：`log.info("Method started: class={}, method={}, params={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(params));`
    - **Service 方法出口**：
      - 建议打印（关键业务必须打印）。
      - 格式：`log.info("Method finished: class={}, method={}, result={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(result));`
    - **异常捕获**：
      - 必须打印堆栈信息。
      - 格式：`log.error("Method failed: class={}, method={}, params={}, error={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(params), e.getMessage(), e);`
    - **逻辑分支**：
      - 关键的 if/else 或 switch 分支必须打印日志记录决策路径。
  - **敏感信息脱敏**：
    - 在打印日志（尤其是 JSON 序列化）时，必须对手机号、身份证、密码等敏感字段进行脱敏处理（建议使用 Fastjson Filter 或 Logback Masking）。

- **事务与并发控制规范**：
  - **事务管理**：
    - **注解使用**：必须使用 `@Transactional(rollbackFor = Exception.class)`，禁止使用默认配置（仅回滚 RuntimeException）。
    - **范围控制**：仅在 Service 层方法上添加事务，禁止在 Controller 层或耗时操作（如 RPC、文件 IO）上加事务。
    - **失效场景**：注意自调用失效问题，必须通过 `AopContext.currentProxy()` 调用或注入自身 Bean。
  - **并发控制**：
    - **分布式锁**：使用 Redisson 实现。
    - **锁粒度**：Key 必须包含业务唯一标识（如 `lock:order:pay:{orderId}`）。
    - **使用模式**：必须使用 try-finally 块释放锁。
      ```java
      RLock lock = redissonClient.getLock("key");
      if (lock.tryLock()) {
          try {
              // 业务逻辑
          } finally {
              lock.unlock();
          }
      }
      ```
  - **并发控制判断标准**（AI 生成代码专用）：
    - **判断流程**：
      1. **是否是写操作？** → 否：无需并发控制
      2. **是否涉及资金/库存扣减？** → 是：必须使用分布式锁
      3. **是否涉及多表事务？** → 是：使用数据库行锁（`@Version` 或 `SELECT FOR UPDATE`）
      4. **是否存在竞态条件？** → 是：使用 Redis 分布式锁
    - **锁选择策略**：
      | 场景 | 锁类型 | 示例 |
      |------|--------|------|
      | 库存扣减、余额扣减 | 分布式锁 (Redisson) | `lock:stock:reduce:{skuId}` |
      | 订单创建（防重复提交） | 分布式锁 | `lock:order:create:{userId}` |
      | 多表数据一致性 | 数据库行锁 | `@Version` 乐观锁 |
      | 单表状态更新 | 无需额外锁 | 依赖数据库事务 |
    - **代码示例**：
      ```java
      // ✅ 正确示例 - 库存扣减使用分布式锁
      @Override
      @Transactional(rollbackFor = Exception.class)
      public boolean reduceStock(Long skuId, Integer quantity) {
          String lockKey = "lock:stock:reduce:" + skuId;
          RLock lock = redissonClient.getLock(lockKey);
          
          if (!lock.tryLock()) {
              throw new BusinessException(BizCodeEnum.STOCK_BUSY);
          }
          
          try {
              // 库存扣减逻辑
              StockEntity stock = stockMapper.selectOne(
                  new LambdaQueryWrapper<StockEntity>()
                      .eq(StockEntity::getSkuId, skuId)
                      .gt(StockEntity::getStock, quantity)
              );
              if (stock == null) {
                  throw new BusinessException(BizCodeEnum.PRODUCT_STOCK_INSUFFICIENT);
              }
              stock.setStock(stock.getStock() - quantity);
              stockMapper.updateById(stock);
          } finally {
              lock.unlock();
          }
          return true;
      }
      
      // ❌ 错误示例 - 库存扣减不使用锁
      public boolean reduceStock(Long skuId, Integer quantity) {
          StockEntity stock = stockMapper.selectById(skuId);
          stock.setStock(stock.getStock() - quantity);  // 并发问题
          stockMapper.updateById(stock);
      }
      ```
  - **幂等性判断标准**（AI 生成代码专用）：
    - **必须幂等的场景**：
      - 支付/扣款类操作（重复支付会导致资损）
      - 下单类操作（重复下单会导致库存超卖）
      - 库存扣减类操作（重复扣减会导致负库存）
      - 状态流转类操作（重复流转会导致状态异常）
    - **建议幂等的场景**：
      - 加购操作（重复加购无大碍，但建议幂等）
      - 收藏/点赞操作（重复操作无意义）
    - **无需幂等的场景**：
      - 纯查询接口（GET）
      - 只读操作（如列表查询、详情查询）
    - **幂等性实现方案**：
      | 方案 | 适用场景 | 实现方式 |
      |------|----------|----------|
      | 唯一键 + INSERT IGNORE | 插入操作 | 使用业务唯一键作为 Redis Key |
      | 状态机 + 条件更新 | 状态流转 | `UPDATE ... WHERE status=PENDING AND id=?` |
      | 分布式锁 | 并发防重 | 获取锁后执行，同一请求只能进入一次 |
      | Token 机制 | 表单提交 | 前端提交 Token，后端验证后删除 |
    - **Redis 幂等 Key 规范**：
      - 格式：`idempotent:{业务}:{唯一标识}`
      - 示例：
        - `idempotent:order:create:{userId}:{skuId}` - 防止重复下单
        - `idempotent:payment:pay:{orderId}` - 防止重复支付
        - `idempotent:stock:reduce:{skuId}` - 防止重复扣减
      - 过期时间：建议 24 小时（根据业务调整）
    - **代码示例**：
      ```java
      // ✅ 正确示例 - 使用 Redis 实现订单创建幂等
      @Override
      @Transactional(rollbackFor = Exception.class)
      public Long createOrder(OrderCreateReq req) {
          String idempotentKey = "idempotent:order:create:" + req.getUserId() + ":" + req.getSkuId();
          Boolean acquired = redisTemplate.opsForValue().setIfAbsent(
              idempotentKey, "1", 24, TimeUnit.HOURS);
          
          if (Boolean.FALSE.equals(acquired)) {
              throw new BusinessException(BizCodeEnum.ORDER_DUPLICATE_SUBMIT);
          }
          
          try {
              // 订单创建逻辑
              // 1. 校验库存
              // 2. 创建订单
              // 3. 扣减库存
          } catch (Exception e) {
              redisTemplate.delete(idempotentKey);  // 失败时删除 Key，允许重试
              throw e;
          }
          return orderId;
      }
      
      // ✅ 正确示例 - 使用状态机实现订单取消幂等
      @Override
      @Transactional(rollbackFor = Exception.class)
      public void cancelOrder(Long orderId) {
          // 使用条件更新实现幂等
          int rows = orderMapper.updateStatusByIdAndStatus(
              orderId, 
              OrderStatusEnum.PENDING.getValue(),  // 前置状态
              OrderStatusEnum.CANCELLED.getValue()  // 目标状态
          );
          
          if (rows == 0) {
              // 找不到待取消的订单，说明订单已被取消或状态异常
              throw new BusinessException(BizCodeEnum.ORDER_STATUS_ERROR);
          }
      }
      
      // ❌ 错误示例 - 不做幂等控制
      @Override
      public void cancelOrder(Long orderId) {
          OrderEntity order = orderMapper.selectById(orderId);
          if (order.getStatus().equals(OrderStatusEnum.PENDING)) {
              order.setStatus(OrderStatusEnum.CANCELLED);  // 并发时可能重复取消
              orderMapper.updateById(order);
          }
      }
      ```

- **注释规范**：
  - Service 接口及实现类方法必须添加 Javadoc 注释，包含 `@param`, `@return`, `@throws`。
  - Controller 方法必须添加 Javadoc 注释，说明接口用途。
  - Mapper 方法必须添加 Javadoc 注释。

- **代码示例（正确 vs 错误）**：
  - **Service 接口**：
    ```java
    // ✅ 正确示例
    public interface UserService {
        /**
         * 根据ID查询用户
         *
         * @param id 用户ID
         * @return 用户信息
         * @throws BusinessException 用户不存在
         */
        UserResp getById(Long id) throws BusinessException;
        
        /**
         * 创建用户
         *
         * @param req 创建请求
         * @return 用户ID
         */
        Long createUser(UserCreateReq req);
    }
    
    // ❌ 错误示例
    public interface UserService {  // 缺少注释
        User getById(Long id);  // 返回类型不明确，缺少注释
        
        Long addUser(User user);  // 方法命名不符合规范
    }
    ```
  - **Service 实现类**：
    ```java
    // ✅ 正确示例
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class UserServiceImpl implements UserService {
        private final UserDalService userDalService;
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public Long createUser(UserCreateReq req) {
            log.info("Method started: class={}, method={}, params={}", 
                "UserServiceImpl", "createUser", JSON.toJSONString(req));
            
            // 业务逻辑
            UserEntity entity = UserEntity.builder()
                .phone(req.getPhone())
                .build();
            userDalService.save(entity);
            
            log.info("Method finished: class={}, method={}, result={}", 
                "UserServiceImpl", "createUser", entity.getId());
            return entity.getId();
        }
    }
    
    // ❌ 错误示例
    @Service
    public class UserServiceImpl implements UserService {  // 缺少 @Slf4j
        @Autowired
        private UserDalService userDalService;  // 缺少 @RequiredArgsConstructor
        
        @Override
        public Long createUser(UserCreateReq req) {  // 缺少 @Transactional(rollbackFor = Exception.class)
            // 缺少日志
            if (req == null) {
                return null;  // 禁止返回 null
            }
            userDalService.save(req);
            return 1L;  // 应该是新增实体的ID
        }
    }
    ```
  - **Controller**：
    ```java
    // ✅ 正确示例
    @Tag(name = "用户管理")
    @RestController
    @RequestMapping("/api/user")
    @RequiredArgsConstructor
    public class UserController {
        private final UserService userService;
        
        @Operation(summary = "根据ID获取用户")
        @GetMapping("/{id}")
        public Result<UserResp> getById(@Parameter(description = "用户ID") @PathVariable Long id) {
            UserResp resp = userService.getById(id);
            return Result.success(resp);
        }
    }
    
    // ❌ 错误示例
    @RestController
    @RequestMapping("/api/user")
    public class UserController {  // 缺少 @Tag 注解
        @Autowired
        private UserService userService;
        
        @GetMapping("/{id}")
        public Result getById(Long id) {  // 缺少 @Operation 和 @Parameter 注解，泛型类型不明确
            return Result.success(userService.getById(id));
        }
    }
    ```
  - **Entity**：
    ```java
    // ✅ 正确示例
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @TableName("{{TABLE_PREFIX}}user")
    public class UserEntity extends BaseEntity {
        @TableField("user_name")
        private String userName;
        
        @TableField("phone")
        private String phone;
    }
    
    // ❌ 错误示例
    @Data
    @TableName("{{TABLE_PREFIX}}user")
    public class UserEntity extends BaseEntity {  // 缺少 @Builder, @NoArgsConstructor, @AllArgsConstructor
        private Long id;  // 主键应在 BaseEntity 中定义
        private String userName;  // 缺少 @TableField
        private Integer isDeleted;  // 缺少 @TableLogic
    }
    ```
  - **枚举类**：
    ```java
    // ✅ 正确示例
    @Getter
    public enum UserStatusEnum implements IEnum<Integer> {
        DISABLED(0, "禁用"),
        ENABLED(1, "启用");
        
        private final Integer value;
        private final String desc;
        
        UserStatusEnum(Integer value, String desc) {
            this.value = value;
            this.desc = desc;
        }
    }
    
    // ❌ 错误示例
    public enum UserStatus {  // 缺少 Enum 后缀
        DISABLED(0),  // 缺少描述
        ENABLED(1);
        
        private final int value;
    }
    ```
  - **异常处理**：
    ```java
    // ✅ 正确示例 - Service 层抛出异常
    @Override
    public UserResp getById(Long id) {
        UserEntity entity = userDalService.getById(id);
        if (entity == null) {
            throw new BusinessException(BizCodeEnum.USER_NOT_FOUND);
        }
        return convertToResp(entity);
    }
    
    // ❌ 错误示例 - Service 层返回 null 或错误码
    @Override
    public UserResp getById(Long id) {
        UserEntity entity = userDalService.getById(id);
        if (entity == null) {
            return null;  // 禁止返回 null
        }
        return convertToResp(entity);
    }
    // 或者
    @Override
    public UserResp getById(Long id) {
        // ...
        return Result.error(BizCodeEnum.USER_NOT_FOUND.getCode(), BizCodeEnum.USER_NOT_FOUND.getMessage());  // Service 层禁止直接返回 Result
    }
    ```

- **参数校验规范**：
  - **校验层级**：
    | 层级 | 校验方式 | 适用场景 | 错误码 |
    |------|----------|----------|--------|
    | Controller 层 | `@Valid` + JSR-303 注解 | 简单格式校验（非空、长度、正则） | 000100 |
    | Service 层 | 手动校验 + `BusinessException` | 业务逻辑校验（唯一性、状态判断） | 对应模块错误码 |
    - **强制要求**：禁止在 Mapper 层进行校验
  - **校验规则结构化规范**（AI 生成代码专用）：
    - API 接口文档中必须使用以下结构化格式定义校验规则：
      ```markdown
      | 字段名 | 规则类型 | 具体约束 | 错误码 | 错误提示 |
      |--------|----------|----------|--------|----------|
      | skuName | 非空 | - | 200100 | 商品名称不能为空 |
      | email | 格式 | 正则：^[\w-]+@[\w]+\.[\w]+$ | 200101 | 邮箱格式不正确 |
      | price | 数值 | > 0, 最多2位小数 | 200102 | 价格必须大于0 |
      | skuCode | 唯一性 | 查询 sku 表 | 203000 | 商品编码已存在 |
      | orderId | 存在性 | 查询 order 表，状态=PENDING | 302000 | 订单状态不可取消 |
      ```
    - **规则类型定义**：
      | 规则类型 | 说明 | JSR-303 注解 | 校验位置 |
      |----------|------|--------------|----------|
      | 非空 | 字段不能为 null 或空字符串 | `@NotNull`, `@NotBlank` | Controller |
      | 长度 | 字符串长度范围 | `@Size(min=?, max=?)` | Controller |
      | 格式 | 正则匹配 | `@Pattern(regexp="...")` | Controller |
      | 数值 | 数值范围 | `@Min`, `@Max`, `@DecimalMin` | Controller |
      | 邮箱 | 邮箱格式 | `@Email` | Controller |
      | 手机号 | 手机号格式 | `@Pattern` | Controller |
      | 枚举值 | 必须是指定枚举值之一 | `@EnumValue` (自动转换) | Controller |
      | 唯一性 | 数据库唯一约束校验 | - | Service |
      | 存在性 | 数据库记录存在性校验 | - | Service |
      | 状态约束 | 数据状态满足操作条件 | - | Service |
      | 关联校验 | 关联数据有效性校验 | - | Service |
  - **常用校验注解**：
    | 注解 | 作用 | 示例 |
    |------|------|------|
    | `@NotNull` | 不能为 null | `@NotNull(message = "ID不能为空")` |
    | `@NotBlank` | 不能为空字符串 | `@NotBlank(message = "用户名不能为空")` |
    | `@Size` | 长度范围 | `@Size(min = 6, max = 20, message = "密码长度6-20位")` |
    | `@Pattern` | 正则校验 | `@Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式错误")` |
    | `@Min`/`@Max` | 数值范围 | `@Min(value = 1, message = "页码最小为1")` |
    | `@Email` | 邮箱格式 | `@Email(message = "邮箱格式错误")` |
    | `@DecimalMin`/`@DecimalMax` | BigDecimal 范围 | `@DecimalMin(value = "0.01", message = "价格必须大于0")` |
  - **代码示例**：
    ```java
    // ✅ 正确示例 - Controller 层使用 @Valid
    @PostMapping
    public Result<Long> create(@RequestBody @Valid UserCreateReq req) {
        Long id = userService.createUser(req);
        return Result.success(id);
    }
    
    // DTO 中定义校验规则
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class UserCreateReq {
        @NotBlank(message = "手机号不能为空")
        @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式错误")
        private String phone;
        
        @NotBlank(message = "密码不能为空")
        @Size(min = 6, max = 20, message = "密码长度6-20位")
        private String password;
        
        @Email(message = "邮箱格式错误")
        private String email;
    }
    
    // ✅ 正确示例 - Service 层手动校验
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Long createUser(UserCreateReq req) {
        // 业务逻辑校验
        if (userDalService.existsByPhone(req.getPhone())) {
            throw new BusinessException(BizCodeEnum.USER_PHONE_EXISTS);
        }
        
        UserEntity entity = UserEntity.builder()
            .phone(req.getPhone())
            .build();
        userDalService.save(entity);
        return entity.getId();
    }
    
    // ❌ 错误示例
    @PostMapping
    public Result<Long> create(@RequestBody UserCreateReq req) {  // 缺少 @Valid
        // 缺少校验
        Long id = userService.createUser(req);
        return Result.success(id);
    }
    
    // ❌ 错误示例 - Service 层直接返回 null
    @Override
    public UserResp getById(Long id) {
        UserEntity entity = userDalService.getById(id);
        if (entity == null) {
            return null;  // 禁止返回 null，必须抛出异常
        }
        return convertToResp(entity);
    }
    ```

- **数据持久层 (Mapper)**：
  - 继承 MyBatis-Plus 的 `BaseMapper<T>` 接口。
  - 涉及到分页查询时，必须使用ID作为排序分页查询的依据, 确保分页查询的结果是连续的。
  - 必须提供的自定义 CRUD 方法 (如果 BaseMapper 不满足): 
    - `insertBatch(List<T> list)`
    - `selectByCondition(T query)`
    - `selectOrderByIdPage(T query, Long lastId, Integer limit)`
    - `selectOrderByIdList(T query, Long lastId, Integer limit)`
    - `updateById(T entity)`
    - `deleteById(Long id)`

- **异常处理规范**：
  - **自定义异常**：
    - 创建 `BusinessException` 继承 `RuntimeException`。
    - 必须包含字段：`String code` (错误码), `String message` (错误信息)。
  - **全局异常处理 (GlobalExceptionHandler)**：
    - 使用 `@RestControllerAdvice` 注解。
    - **处理逻辑**：
      - 捕获 `BusinessException` -> 返回 `Result.error(e.getCode(), e.getMessage())`。
      - 捕获 `MethodArgumentNotValidException` (参数校验失败) -> 返回 `Result.error("000100", "参数校验失败: " + fieldError.getDefaultMessage())`。
      - 捕获 `Exception` (兜底) -> 打印 Error 日志 -> 返回 `Result.error("009000", "系统繁忙，请稍后重试")`。
  - **抛出原则**：
    - 业务层 (Service) 遇到逻辑错误（如库存不足、用户不存在），**必须**抛出 `BusinessException`，禁止直接返回 null 或错误码对象。
    - 禁止在 Controller 层捕获异常（除非为了特殊降级处理），应统一由全局异常处理器接管。

- **第三方服务集成**：
  - 独立模块 (如 `third-party-sms`)。
  - 定义统一接口 (如 `SmsService`) 继承 IApiService，实现类与接口同名，后缀为 `Impl`，如 `SmsServiceImpl`中封装具体逻辑, IApiService 代码如下：
    ```java
    public interface IApiService {
    /**
     * 请求 指定业务 服务器
     *
     * @param request 请求
     * @param <Resp>  响应
     */
    <Resp extends ApiResponse> Resp request(ApiRequest<Resp> request) throws ApiException;
    /**
     * 请求 指定业务 服务器
     *
     * @param trackId 追踪ID
     * @param request 请求
     * @param <Resp>  响应
     */
    <Resp extends ApiResponse> Resp request(String trackId, ApiRequest<Resp> request) throws ApiException;
    }
    ```
    ```java
    public interface ApiRequest<resp extends ApiResponse> extends Serializable {
    /**
     * 请求的路径
     */
    String requestMappingUrl();
    /**
     * 是否对请求body进行加密处理
     */
    default boolean ciphertextEnable() {
        return false;
    }
    /**
     * 请求的响应结构体
     */
    Class<resp> respClass();
    /**
     * 请求所带的token
     */
    default String accessToken(){
        return null;
    }
    }
    ```
    ```java
    public interface ApiResponse extends Serializable {
    }
    ```
  - 定义统一HTTP调用方式使用 **Feign Client**，实现类添加 `@FeignClient` 注解。
  - 定义统一HTTP调用方法：
    ```java
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    String postByURI(URI uri, @RequestHeader("trackId") String trackId, @RequestBody Object body);
    ```
  - **Feign 日志规范 (CURL)**：
    - **强制要求**：所有 Feign 客户端必须配置自定义 `Logger` 实现类 FeignLogger，将请求日志格式化为 `curl` 命令。
    - **日志级别**：Feign Client 配置必须设为 `Logger.Level.FULL`。
    - **请求日志 (`logRequest`)**：
       - 必须包含：Method, URL, Headers, Body。
       - 格式要求：使用多行 `curl` 命令格式，每行一个参数，使用 `\` 换行，确保可读性和直接复制执行。
       - 示例：
         ```bash
         curl -X POST 'https://api.example.com/v1/users' \
           -H 'Content-Type: application/json' \
           -H 'Authorization: Bearer xxxxx' \
           -d '{
             "name": "test",
             "age": 18
           }'
         ```
     - **响应日志 (`logAndRebufferResponse`)**：
      - 必须包含：HTTP Status, 耗时 (Latency), Response Body。
      - 示例：`FEIGN_RESP -> curl -X POST 'http://10.0.0.1/api/sms' [status:200] (120ms) body: {"code":"200","msg":"success"}`
    - **异常日志**：
      - 当 Feign 调用抛出异常时，必须在 ERROR 级别日志中打印原始请求的 CURL 命令。

- **异步处理与事件驱动规范**：
  - **核心原则**：
    - 接口响应时间超过 500ms 的核心提交操作，必须采用异步处理。
    - 核心业务流程中的副作用（Side Effects，如发通知、统计）必须通过事件解耦。
  - **技术实现**：
    - **实现方式**：使用 Spring Event (`ApplicationEventPublisher`) 配合 `@EventListener` 和 `ThreadPoolTaskExecutor` 实现进程内解耦。
    - **发布事件**：
      ```java
      @Autowired
      private ApplicationEventPublisher eventPublisher;
      @Autowired
      private ThreadPoolTaskExecutor taskExecutor;

      public void publishEvent(DelayHandleTaskEvent event, boolean isAsync) {
        if (isAsync) {
            taskExecutor.execute(() -> eventPublisher.publishEvent(event));
        } else {
            eventPublisher.publishEvent(event);
        }
      }
      ```
    - **监听事件**：
      ```java
      @Component
      public class DelayHandleTaskListener {
          @EventListener
          public void handleDelayHandleTaskEvent(DelayHandleTaskEvent event) {
              // 异步处理逻辑
          }
      }
      ```
    - **强制要求**：
      - 必须配置自定义线程池 (TaskExecutor)，禁止使用 Spring 默认的 SimpleAsyncTaskExecutor。
      - 事件类名必须以 `Event` 结尾 (如 `OrderCreatedEvent`)。
    - **分布式异步**：在跨服务解耦时使用 MQ/Redis。
  - **API 交互模式**：
    - **提交接口**：
      - 收到请求后，生成 `taskId`，存入 Redis/DB 初始化状态为 `PENDING`。
      - 通过 `eventPublisher.publishEvent(...)` 触发异步处理。
      - 立即返回响应：`{ "code": "200", "data": { "taskId": "t_1001", "status": "PENDING" } }`。
    - **结果轮询接口**：
      - 前端轮询 `GET /api/async-tasks/{taskId}` (建议间隔 1s/3s/5s 退避)。
      - 响应结构：
        ```json
        {
          "code": "200",
          "data": {
            "taskId": "t_1001",
            "status": "SUCCESS", // PENDING, PROCESSING, SUCCESS, FAILED
            "progress": 100,     // 可选：进度百分比
            "result": { ... },   // 成功时的业务数据
            "errorMsg": null     // 失败时的错误信息
          }
        }
        ```
  - **异常与兜底**：
    - 异步方法内部**必须** try-catch 所有异常。
    - 捕获异常后：1. 打印 ERROR 日志；2. 将任务状态更新为 `FAILED`；3. 记录错误信息。

- **Git 提交与版本管理**：
  - **Commit Message**：采用 Conventional Commits 规范。
    - `feat`: 新功能
    - `fix`: 修复 Bug
    - `docs`: 文档变更
    - `style`: 代码格式调整 (不影响逻辑)
    - `refactor`: 代码重构
    - `chore`: 构建/工具链变动
  - **分支管理**：
    - `main/master`: 主分支，随时可发布。
    - `develop`: 开发分支。
    - `feature/*`: 功能分支，从 main/master 新建，完成后合并到 develop。

- **配置文件规范**：
  - **命名规范**：
    - 配置文件：`application-{env}.yml`
    - 配置项：使用 kebab-case (如 `custom-thread-pool.core-size`)。
  - **配置结构**：
    ```yaml
    server:
      port: 8080
    spring:
      application:
        name: {{SERVICE_NAME}}
      datasource: ...
      redis: ...
    # 自定义配置
    app:
      sms:
        enabled: true
      thread-pool:
        core-size: 10
    ```
  - **多环境配置**：
    - `application.yml`: 公共配置
    - `application-sit.yml`: 测试环境
    - `application-prod.yml`: 生产环境
  - **敏感信息**：
    - 生产环境密码、密钥禁止明文提交到代码库，应通过环境变量或 CI/CD 注入。

- **测试规范**：
  - **技术选型**：JUnit 5 + Spring Boot Test + H2/Mockito。
  - **单元/集成测试**：
    - **注解使用**：
      - 使用 `@SpringBootTest` 启动完整上下文（适用于验证 Service与 DB/Cache 的集成逻辑）。
      - 配合 `@Transactional` 确保测试数据回滚，不污染数据库。
    - **Mock 策略**：
      - 外部服务（如 Feign Client）必须使用 `@MockBean` 进行模拟，隔离外部依赖。
    - **代码示例**：
      ```java
      @SpringBootTest
      @Transactional // 自动回滚事务
      @Slf4j
      class UserServiceTest {
          @Autowired
          private UserService userService;
          
          @MockBean // Mock 外部短信服务
          private SmsService smsService;

          @Test
          void should_create_user_success() {
              // Arrange
              UserCreateReq req = new UserCreateReq("test_user");
              when(smsService.sendCode(anyString())).thenReturn(true);
              
              // Act
              Long userId = userService.createUser(req);
              
              // Assert
              assertThat(userId).isNotNull();
              // 验证 DB 是否写入 (Integration Test 优势)
              UserVO user = userService.getUserById(userId);
              assertThat(user.getUsername()).isEqualTo("test_user");
          }
      }
      ```
  - **测试覆盖率**：核心业务模块行覆盖率建议 > 60%。

- **代码模板（快速生成）**：
  - **Entity 模板**：
    ```java
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @TableName("{{TABLE_PREFIX}}{table_name}")
    public class {ClassName}Entity extends BaseEntity {
        @TableField("{field_name}")
        private {FieldType} {fieldName};
    }
    ```
  - **DTO 请求模板**：
    ```java
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class {ClassName}Req {
        @NotBlank(message = "xxx不能为空")
        private String xxx;
    }
    ```
  - **VO 响应模板**：
    ```java
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class {ClassName}Resp {
        private Long id;
        private String xxx;
    }
    ```
  - **Mapper 模板**：
    ```java
    @Mapper
    public interface {ClassName}Mapper extends BaseMapper<{ClassName}Entity> {
        /**
         * 根据条件查询列表
         *
         * @param query 查询条件
         * @return 实体列表
         */
        List<{ClassName}Entity> selectByCondition(@Param("query") {ClassName}Query query);
        
        /**
         * 游标分页查询
         *
         * @param query 查询条件
         * @param lastId 游标ID
         * @param limit 每页大小
         * @return 实体列表
         */
        List<{ClassName}Entity> selectOrderByIdPage(@Param("query") {ClassName}Query query,
                                                     @Param("lastId") Long lastId,
                                                     @Param("limit") Integer limit);
    }
    ```
  - **DAL Service 接口模板**：
    ```java
    public interface {ClassName}DalService {
        /**
         * 新增
         *
         * @param entity 实体
         * @return 是否成功
         */
        boolean save({ClassName}Entity entity);
        
        /**
         * 根据ID查询
         *
         * @param id 主键ID
         * @return 实体
         */
        {ClassName}Entity getById(Long id);
        
        /**
         * 修改
         *
         * @param entity 实体
         * @return 是否成功
         */
        boolean updateById({ClassName}Entity entity);
        
        /**
         * 根据ID删除
         *
         * @param id 主键ID
         * @return 是否成功
         */
        boolean deleteById(Long id);
        
        /**
         * 根据条件查询列表
         *
         * @param query 查询条件
         * @return 实体列表
         */
        List<{ClassName}Entity> listByCondition({ClassName}Query query);
    }
    ```
  - **DAL Service 实现模板**：
    ```java
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class {ClassName}DalServiceImpl implements {ClassName}DalService {
        private final {ClassName}Mapper {className}Mapper;
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public boolean save({ClassName}Entity entity) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}DalServiceImpl", "save", JSON.toJSONString(entity));
            boolean result = {className}Mapper.insert(entity) > 0;
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}DalServiceImpl", "save", result);
            return result;
        }
        
        @Override
        public {ClassName}Entity getById(Long id) {
            return {className}Mapper.selectById(id);
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public boolean updateById({ClassName}Entity entity) {
            return {className}Mapper.updateById(entity) > 0;
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public boolean deleteById(Long id) {
            return {className}Mapper.deleteById(id) > 0;
        }
        
        @Override
        public List<{ClassName}Entity> listByCondition({ClassName}Query query) {
            return {className}Mapper.selectByCondition(query);
        }
    }
    ```
  - **Service 接口模板**：
    ```java
    public interface {ClassName}Service {
        /**
         * 根据ID查询
         *
         * @param id 主键ID
         * @return 响应对象
         * @throws BusinessException 实体不存在
         */
        {ClassName}Resp getById(Long id) throws BusinessException;
        
        /**
         * 创建
         *
         * @param req 请求对象
         * @return 主键ID
         */
        Long create({ClassName}Req req);
        
        /**
         * 修改
         *
         * @param req 请求对象
         */
        void update({ClassName}Req req);
        
        /**
         * 根据ID删除
         *
         * @param id 主键ID
         */
        void deleteById(Long id);
        
        /**
         * 分页查询
         *
         * @param query 查询条件
         * @return 分页结果
         */
        PageResult<{ClassName}Resp> page({ClassName}Query query);
    }
    ```
  - **Service 实现模板**：
    ```java
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class {ClassName}ServiceImpl implements {ClassName}Service {
        private final {ClassName}DalService {className}DalService;
        private final {ClassName}Mapper {className}Mapper;
        
        @Override
        public {ClassName}Resp getById(Long id) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "getById", id);
            {ClassName}Entity entity = {className}DalService.getById(id);
            if (entity == null) {
                throw new BusinessException("{BIZ_CODE_NOT_FOUND}", "{ClassName}不存在");
            }
            {ClassName}Resp resp = convertToResp(entity);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "getById", resp.getId());
            return resp;
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public Long create({ClassName}Req req) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "create", JSON.toJSONString(req));
            // 参数校验
            this.validate(req);
            // 业务逻辑
            {ClassName}Entity entity = convertToEntity(req);
            {className}DalService.save(entity);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "create", entity.getId());
            return entity.getId();
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public void update({ClassName}Req req) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "update", JSON.toJSONString(req));
            // 参数校验
            this.validate(req);
            {ClassName}Entity entity = {className}DalService.getById(req.getId());
            if (entity == null) {
                throw new BusinessException("{BIZ_CODE_NOT_FOUND}", "{ClassName}不存在");
            }
            // 更新逻辑
            this.updateEntity(entity, req);
            {className}DalService.updateById(entity);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "update", req.getId());
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public void deleteById(Long id) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "deleteById", id);
            {ClassName}Entity entity = {className}DalService.getById(id);
            if (entity == null) {
                throw new BusinessException("{BIZ_CODE_NOT_FOUND}", "{ClassName}不存在");
            }
            {className}DalService.deleteById(id);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "deleteById", id);
        }
        
        @Override
        public PageResult<{ClassName}Resp> page({ClassName}Query query) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "page", JSON.toJSONString(query));
            // 分页查询
            List<{ClassName}Entity> list = {className}Mapper.selectOrderByIdPage(
                query, query.getLastId(), query.getPageSize());
            long total = {className}Mapper.selectCount(query);
            List<{ClassName}Resp> respList = list.stream()
                .map(this::convertToResp)
                .collect(Collectors.toList());
            log.info("Method finished: class={}, method={}, result={{}, {}}}",
                "{ClassName}ServiceImpl", "page", total, respList.size());
            return PageResult.<{ClassName}Resp>builder()
                .total(total)
                .list(respList)
                .build();
        }
        
        private void validate({ClassName}Req req) {
            // 参数校验逻辑
        }
        
        private {ClassName}Entity convertToEntity({ClassName}Req req) {
            return {ClassName}Entity.builder()
                .xxx(req.getXxx())
                .build();
        }
        
        private {ClassName}Resp convertToResp({ClassName}Entity entity) {
            return {ClassName}Resp.builder()
                .id(entity.getId())
                .xxx(entity.getXxx())
                .build();
        }
        
        private void updateEntity({ClassName}Entity entity, {ClassName}Req req) {
            entity.setXxx(req.getXxx());
        }
    }
    ```
  - **Controller 模板**：
    ```java
    @Tag(name = "{模块名}")
    @RestController
    @RequestMapping("/api/{module-name}")
    @RequiredArgsConstructor
    public class {ClassName}Controller {
        private final {ClassName}Service {className}Service;
        
        @Operation(summary = "根据ID查询")
        @GetMapping("/{id}")
        public Result<{ClassName}Resp> getById(@Parameter(description = "ID") @PathVariable Long id) {
            {ClassName}Resp resp = {className}Service.getById(id);
            return Result.success(resp);
        }
        
        @Operation(summary = "创建")
        @PostMapping
        public Result<Long> create(@RequestBody @Valid {ClassName}Req req) {
            Long id = {className}Service.create(req);
            return Result.success(id);
        }
        
        @Operation(summary = "修改")
        @PutMapping
        public Result<Void> update(@RequestBody @Valid {ClassName}Req req) {
            {className}Service.update(req);
            return Result.success();
        }
        
        @Operation(summary = "根据ID删除")
        @DeleteMapping("/{id}")
        public Result<Void> deleteById(@Parameter(description = "ID") @PathVariable Long id) {
            {className}Service.deleteById(id);
            return Result.success();
        }
        
        @Operation(summary = "分页查询")
        @GetMapping("/page")
        public Result<PageResult<{ClassName}Resp>> page(@ModelAttribute {ClassName}Query query) {
            PageResult<{ClassName}Resp> pageResult = {className}Service.page(query);
            return Result.success(pageResult);
        }
    }
    ```
  - **枚举模板**：
    ```java
    @Getter
    public enum {ClassName}Enum implements IEnum<Integer> {
        STATUS_1(1, "状态一"),
        STATUS_2(2, "状态二");
        
        private final Integer value;
        private final String desc;
        
        {ClassName}Enum(Integer value, String desc) {
            this.value = value;
            this.desc = desc;
        }
    }
    ```
  - **常量类模板**：
    ```java
    public class {ClassName}Const {
        public static final String KEY_PREFIX = "xxx:";
        public static final int DEFAULT_PAGE_SIZE = 10;
        public static final int MAX_PAGE_SIZE = 100;
    }
    ```
  - **异常类模板**：
    ```java
    @Getter
    public class BusinessException extends RuntimeException {
        private final String code;
        
        public BusinessException(String code, String message) {
            super(message);
            this.code = code;
        }
    }
    ```
