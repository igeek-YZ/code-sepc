# 后端 API 接口定义规范

本文档旨在统一后端 API 接口的设计格式与内容规范，确保接口文档的清晰性、一致性及可维护性。所有新开发的 API 接口均需遵循此规范。

## 一、 接口文档结构

每个 API 接口的定义应包含以下核心要素：

1.  **接口名称**：清晰简练地描述接口功能（如：商品列表 API）。
2.  **接口地址 (URL)**：HTTP 方法与路径（如：`GET /api/products`）。
3.  **请求参数 (Request Parameters)**：
    *   **Query/Path 参数**：URL 路径参数或查询字符串参数。
    *   **请求体 (Request Body)**：JSON 格式的请求数据结构。
    *   **字段说明**： Query/Path 参数/请求体 字段说明。
4.  **安全与权限 (Security & Permission)**：明确接口的鉴权方式及权限要求。
5.  **验证规则 (Validation Rules)**：详细列出参数的校验逻辑、必填项、格式要求及业务约束。
6.  **响应结果 (Response)**：
    *   成功响应的 JSON 结构示例。
    *   包含标准的状态码 (`code`)、提示信息 (`message`) 及数据载荷 (`data`)。
    *   **字段说明**：
        *   `code`：状态码，200 表示成功，其他值表示错误。
        *   `message`：对状态码的详细描述，用于客户端展示。
        *   `data`：包含实际业务数据的 JSON 对象。

---

## 二、 详细规范说明

### 1. 接口命名
*   **格式**：`{资源名称} + {操作} + API`
*   **示例**：
    *   `商品列表 API`
    *   `代理商添加 API`
    *   `验证码发送 API`

### 2. URL 设计
*   **风格**：RESTful 风格。
*   **版本前缀**：`/api/v{version}`，版本号使用数字主版本号（如 v1, v2）。
    *   示例：`GET /api/v1/products`、`POST /api/v2/orders`
    *   不兼容变更时发布新版本，旧版本至少维护 6 个月
*   **资源命名与操作分层**：
    | 类型 | HTTP 方法 | URL 模式 | 示例 | 说明 |
    |------|-----------|----------|------|------|
    | 资源集合查询 | GET | `/api/v{version}/{plural-resource}` | `GET /api/v1/products` | 查询资源列表 |
    | 单个资源查询 | GET | `/api/v{version}/{plural-resource}/{id}` | `GET /api/v1/products/123` | 查询指定资源 |
    | 关联资源查询 | GET | `/api/v{version}/{plural-resource}/{id}/{child-resource}` | `GET /api/v1/products/123/comments` | 查询资源的子资源 |
    | 特定操作 | GET/POST | `/api/v{version}/{resource}/{action}` | `GET /api/v1/orders/status`、`POST /api/v1/orders/cancel` | 业务特定操作 |
    | 认证登录 | POST | `/api/v{version}/auth/{action}` | `POST /api/v1/auth/login` | 特殊前缀 auth |
*   **路径参数**：使用 `{paramName}` 表示动态路径参数（如 `/api/v1/products/{skuCode}`）。
*   **Query 参数**：用于筛选、排序、分页。
    *   分页：`page`, `pageSize`
    *   排序：`orderBy`（默认 `id DESC`）
    *   筛选：业务字段（如 `status`, `categoryId`）
*   **URL 命名约束**：
    - 资源名使用小写复数名词（`products`, `orders`，非 `productList`）
    - 操作名使用小写单数名词或动词（`status`, `cancel`，非 `getStatus`）
    - 禁止在 URL 中使用驼峰命名
    - 禁止在 URL 中包含动词形式的 HTTP 方法（如 `GET /api/getProducts` 错误）

### 3. 请求定义

#### 3.1 Query / Path 参数
*   **适用场景**：GET 请求筛选、分页，或 RESTful 路径资源定位。
*   **示例**：`GET /api/products?page=1&status=ON_SALE`
*   **字段说明**：
    | 参数名 | 类型 | 必填 | 默认值 | 示例值 | 描述 |
    | :--- | :--- | :--- | :--- | :--- | :--- |
    | `page` | Integer | 否 | 1 | 1 | 分页页码 |
    | `pageSize` | Integer | 否 | 10 | 20 | 每页条数 |
    | `skuCode` | String | 否 | - | "SKU123" | 精确匹配商品编码 |
    | `status` | String | 否 | - | "ON_SALE" | 状态枚举值 |

#### 3.2 请求体 (Request Body)
*   **适用场景**：POST/PUT/PATCH 请求传输复杂结构化数据。
*   **格式**：application/json
*   **JSON 结构示例**：
    ```json
    {
      "skuName": "iPhone 15",
      "price": "5999.00",
      "tags": ["新品", "热销"],
      "specs": { "color": "black", "storage": "128G" }
    }
    ```
*   **字段说明**：
    | 字段名 | 类型 | 必填 | 约束/枚举 | 描述 |
    | :--- | :--- | :--- | :--- | :--- |
    | `skuName` | String | 是 | max:100 | 商品名称 |
    | `price` | String | 是 | >0, 2位小数 | 价格（字符串格式防精度丢失） |
    | `tags` | Array<String> | 否 | max:5 | 标签列表 |
    | `specs` | Object | 否 | - | 规格属性对象 |

### 3.3 字段命名规范
*   **API 字段命名**：统一使用 **camelCase**（小驼峰），与 JSON 格式保持一致。
    | 正例 | 反例 |
    |------|------|
    | `userName` | `user_name`, `UserName` |
    | `orderId` | `order_id`, `OrderId` |
    | `totalStock` | `total_stock`, `TotalStock` |
*   **强制要求**：
    - API 接口的 JSON 请求/响应必须使用 camelCase。
    - 前后端联调时，字段名必须保持一致。
    - 数据库字段使用 snake_case（在 Entity 中通过 `@TableField` 映射）。

### 4. 业务规则与边界 (Business Rules & Edge Cases)
*   **核心逻辑**：简述接口的核心处理流程（如：校验库存 -> 扣减余额 -> 创建订单）。
*   **状态流转**：涉及状态变更时，需明确“前置状态”和“后置状态”（如：仅`PENDING`状态可取消）。
*   **边界条件**：
    *   **并发控制**：
        - **判断标准**：
            1. 是否是写操作？→ 否：无需并发控制
            2. 是否涉及资金/库存扣减？→ 是：必须使用分布式锁
            3. 是否涉及多表事务？→ 是：使用数据库行锁
        - **锁类型选择**：
            | 场景 | 锁类型 | 示例 |
            |------|--------|------|
            | 库存扣减、余额扣减 | 分布式锁 (Redisson) | `lock:stock:reduce:{skuId}` |
            | 订单创建（防重复提交） | 分布式锁 | `lock:order:create:{userId}` |
            | 多表数据一致性 | 数据库行锁 | `@Version` 乐观锁 |
            | 单表状态更新 | 无需额外锁 | 依赖数据库事务 |
    *   **幂等性**：
        - **必须幂等场景**（涉及资金/库存/状态流转）：
            - 支付/扣款类操作（重复支付会导致资损）
            - 下单类操作（重复下单会导致库存超卖）
            - 库存扣减类操作（重复扣减会导致负库存）
            - 状态流转类操作（重复流转会导致状态异常）
        - **建议幂等场景**：
            - 加购操作（重复加购无大碍，但建议幂等）
            - 收藏/点赞操作（重复操作无意义）
        - **无需幂等场景**：
            - 纯查询接口（GET）
            - 只读操作（如列表查询、详情查询）
        - **幂等 Key 格式**：`idempotent:{业务}:{唯一标识}`
            - 示例：`idempotent:order:create:{userId}:{skuId}`
    *   **数据权限**：用户只能操作自己的数据吗？
*   **异常场景**：
    | 场景 | 错误码 | 错误提示 | 处理建议 |
    | :--- | :--- | :--- | :--- |
    | 库存不足 | 20020 | 商品库存不足 | 提示用户减少数量 |
    | 余额不足 | 10020 | 账户余额不足 | 跳转充值页 |
### 5. 安全与权限 (Security & Permission)
*   **鉴权方式**：默认需携带 JWT Token（Header: `Authorization: Bearer {token}`）。
*   **权限注解**：明确对应的后端权限注解，便于 AI 生成安全代码。
*   **请求频次限制**：默认每个用户每个接口每 1 秒最多调用 2 次，可根据业务场景调整。
*   **幂等性**：对于涉及资金或状态流转的关键接口（如加购、支付、下单），需明确是否需要幂等性控制。
*   **示例**：
    *   需要登录：`@PreAuthorize("isAuthenticated()")`
    *   需要特定角色：`@PreAuthorize("hasRole('ADMIN')")`
    *   需要幂等性：`@Idempotent`
    *   需要接口频次限制：`@RateLimit(limit = 2, perSecond = 1)`

### 6. 验证规则 (Validation Rules)
*   **校验层级**：
    | 层级 | 校验方式 | 适用场景 | 错误码 |
    |------|----------|----------|--------|
    | Controller 层 | `@Valid` + JSR-303 注解 | 格式校验（非空、长度、正则） | 00001 |
    | Service 层 | 手动校验 + `BusinessException` | 业务校验（唯一性、状态判断） | 对应模块错误码 |
*   **验证规则结构化格式**（API 接口文档必须使用）：
    | 字段名 | 规则类型 | 具体约束 | 错误码 | 错误提示 |
    |--------|----------|----------|--------|----------|
    | `skuName` | 非空 | - | 400001 | 商品名称不能为空 |
    | `email` | 格式 | 正则：^[\w-]+@[\w]+\.[\w]+$ | 400002 | 邮箱格式不正确 |
    | `price` | 数值 | > 0, 最多2位小数 | 400003 | 价格必须大于0 |
    | `skuCode` | 唯一性 | 查询 sku 表 | 400004 | 商品编码已存在 |
    | `orderId` | 存在性 | 查询 order 表，状态=PENDING | 30020 | 订单状态不可取消 |
*   **规则类型定义**：
    | 规则类型 | 说明 | JSR-303 注解 | 校验位置 |
    |----------|------|--------------|----------|
    | 非空 | 字段不能为 null 或空字符串 | `@NotNull`, `@NotBlank` | Controller |
    | 长度 | 字符串长度范围 | `@Size(min=?, max=?)` | Controller |
    | 格式 | 正则匹配 | `@Pattern(regexp="...")` | Controller |
    | 数值 | 数值范围 | `@Min`, `@Max`, `@DecimalMin` | Controller |
    | 邮箱 | 邮箱格式 | `@Email` | Controller |
    | 手机号 | 手机号格式 | `@Pattern` | Controller |
    | 枚举值 | 必须是指定枚举值之一 | `@EnumValue` (自动转换) | Controller |
    | 唯一性 | 数据库唯一约束校验 | - | Service |
    | 存在性 | 数据库记录存在性校验 | - | Service |
    | 状态约束 | 数据状态满足操作条件 | - | Service |
    | 关联校验 | 关联数据有效性校验 | - | Service |
*   **验证规则编写要点**：
    *   **非空校验**：哪些字段必填。
    *   **格式校验**：如邮箱格式、手机号格式、身份证格式（指定具体正则）。
    *   **业务逻辑校验**：
        *   引用表是否存在（如：检查邮箱是否在代理商表中存在）。
        *   数值范围约束（如：价格 > 0）。
        *   状态约束（如：采购单状态只能是待付款/已完成）。
        *   唯一性约束（如：采购单号已存在则报错）。
    *   **错误提示与错误码**：
        *   明确验证失败时的报错文案（如：【邮箱无效，请联系品牌方】）。
        *   **必须**指定标准错误码（参考错误码规范章节）。

### 6.1 错误码规范
*   **错误码格式**：`{模块码}{类型码}{序号}`，均为数字字符串，共 5 位。
*   **模块码定义**：
    | 模块 | 模块码 | 示例 |
    |------|--------|------|
    | 公共模块 | 00 | 00001 = 系统未知错误 |
    | 用户模块 | 10 | 10010 = 用户不存在, 10020 = 用户已禁用 |
    | 商品模块 | 20 | 20010 = 商品不存在, 20020 = 商品库存不足 |
    | 订单模块 | 30 | 30010 = 订单不存在, 30020 = 订单已取消 |
    | 库存模块 | 40 | 40010 = 库存不足, 40020 = 库存记录不存在 |
    | 支付模块 | 50 | 50010 = 支付失败, 50020 = 支付金额不匹配 |
    | 认证模块 | 60 | 60010 = Token无效, 60020 = Token已过期 |
    | 验证码模块 | 70 | 70010 = 验证码错误, 70020 = 验证码已过期 |
*   **类型码定义**：
    | 类型码范围 | 类型 | 说明 |
    |------------|------|------|
    | 01-09 | 参数校验错误 | 请求参数格式、必填、长度等校验失败 |
    | 10-19 | 数据不存在 | 查询的数据记录不存在 |
    | 20-29 | 状态异常 | 数据状态不满足操作条件（如订单已取消） |
    | 30-39 | 业务规则冲突 | 唯一性约束、业务规则校验失败 |
    | 40-49 | 权限不足 | 用户无权限执行该操作 |
    | 50-59 | 认证失败 | Token无效、登录失效等 |
    | 90-99 | 系统错误 | 内部异常、第三方服务调用失败等 |
*   **错误码使用规范**：
    *   所有业务校验失败**必须**抛出 `BusinessException`，携带标准错误码。
    *   禁止直接硬编码错误码数字，必须通过 `BizCodeEnum` 统一管理。
    *   错误码一旦发布不可变更（保证前端错误码映射表稳定）。
    *   参数校验失败统一使用 `00001`。
*   **异常场景表格模板**：
    | 场景 | 错误码 | 错误提示 | 处理建议 |
    | :--- | :--- | :--- | :--- |
    | 库存不足 | 20020 | 商品库存不足 | 提示用户减少数量 |
    | 余额不足 | 10020 | 账户余额不足 | 跳转充值页 |
    | 用户不存在 | 10010 | 用户不存在 | 检查用户ID是否正确 |
    | Token无效 | 60010 | Token无效，请重新登录 | 跳转登录页 |

### 7. 响应定义
*   **统一格式**：
    ```json
    {
      "code": "200",
      "msg": "success",
      "data": { ... }
    }
    ```
*   **查询类接口响应**（GET 请求获取数据）：
    ```json
    {
      "code": "200",
      "msg": "success",
      "data": { ... }
    }
    // 或列表分页响应
    {
      "code": "200",
      "msg": "success",
      "data": {
        "total": 100,
        "list": [{ ... }]
      }
    }
    ```
*   **操作类接口响应**（POST/PUT/DELETE 请求修改数据）：
    ```json
    {
      "code": "200",
      "msg": "操作成功",
      "data": null
    }
    ```
*   **错误响应**：
    ```json
    {
      "code": "20010",
      "msg": "用户不存在",
      "data": null
    }
    ```
*   **字段规范**：
    | 字段名 | 类型 | 说明 | 必填/可选 |
    |--------|------|------|----------|
    | `code` | String | 状态码，200 表示成功，其他值为错误 | 必填 |
    | `msg` | String | 提示信息 | 操作类接口必填，查询类接口可选 |
    | `data` | Object/Array | 业务数据载荷 | 错误响应中必须为 null |
*   **分页响应结构**：
    ```json
    {
      "code": "200",
      "msg": "success",
      "data": {
        "total": 100,
        "list": [{ "id": 1, "name": "商品A" }]
      }
    }
    ```
*   **Swagger/Knife4j 注解规范**：
    *   Controller 类：`@Tag(name = "xxx")`
    *   接口方法：`@Operation(summary = "xxx")`
    *   参数对象：`@Schema(description = "xxx")`

### 8. 代码生成指引 - for AI
为了避免代码生成过程中的理解偏移，请严格遵守以下实现细节：

1.  **对象边界 (Object Boundary)**：
    *   **严禁**在 Controller 接口中使用数据库实体 (`Entity`) 作为参数或返回值。
    *   **请求参数**：必须封装为独立的 DTO 类（命名后缀建议 `Req` 或 `DTO`，如 `UserCreateReq`）。
    *   **响应结果**：必须封装为独立的 VO 类（命名后缀建议 `Resp` 或 `VO`，如 `UserResp`）。
    *   需生成 Entity 与 DTO/VO 之间的转换代码（使用 MapStruct）。

2.  **分页结构适配**：
    *   后端使用 MyBatis-Plus 的 `Page<T>` 对象进行查询。
    *   **排序要求**：所有分页查询接口，默认**必须**按照 `ID` 进行降序排列 (`ORDER BY id DESC`)，以确保数据的一致性和新数据优先展示。除非业务明确指定了其他排序字段（如 `created_time` 或 `sort_order`）。
    *   **必须**经过转换层，将 `Page` 对象的 `records` 字段映射为 API 文档要求的 `list` 字段。
    *   建议定义通用的 `PageResult<T>` 包装类：
        ```java
        @Data
        public class PageResult<T> {
            private long total;
            private List<T> list;
        }
        ```

3.  **校验逻辑分层**：
    *   **格式校验**（非空、长度、正则）：在 Controller 层使用 JSR-303 注解 (`@NotNull`, `@Pattern`) 处理。
    *   **业务校验**（唯一性、数据库状态）：**必须**下沉到 Service 层实现。Controller 仅负责调用 Service，不处理具体的业务判断逻辑。

4.  **异常与错误码**：
    *   所有业务校验失败，**必须**抛出 `BusinessException`。
    *   错误码枚举类统一命名为 `BizCodeEnum` (或复用项目中已有的枚举)，禁止直接硬编码错误码数字或随意创建新枚举类。

5.  **枚举处理**：
    *   接收参数：使用 MyBatis-Plus 的 `@EnumValue` 或 Spring 的 `Converter` 自动处理 `code` 到 `Enum` 的转换，避免在 Controller 中写 `switch/case`。

---

## 三、 标准示例模板

以下是一个标准的 API 定义示例，请在编写文档时直接复用此模板：

### {模块名称} API

#### 1. {接口名称} API
- **接口**：`{METHOD} /api/v{version}/{resource}/{action}`（如：`POST /api/v1/orders/create`）
- **版本**：v1
- **权限**：需要 {角色/权限} (`@PreAuthorize("...")`)
- **事务**：是/否 (如涉及多表写操作，需标注 `@Transactional`)
- **幂等性**：是/否(默认否，GET接口不需要幂等性)
- **并发控制**：是/否（如涉及库存扣减/资金操作，需使用分布式锁）
- **核心逻辑**：
    1.  校验...
    2.  计算...
    3.  更新...
- **参数**：
    | 参数名 | 类型 | 必填 | 示例 | 描述 |
    | :--- | :--- | :--- | :--- | :--- |
    | `id` | Long | 是 | 1 | ID |
- **请求体**：
    ```json
    { "field1": "value" }
    ```
- **请求体字段**：
    | 字段名 | 类型 | 必填 | 约束 | 错误码 | 错误提示 |
    | :--- | :--- | :--- | :--- | :--- | :--- |
    | `field1` | String | 是 | max:50 | 400001 | 字段1不能为空 |
- **验证规则（结构化）**：
    | 字段名 | 规则类型 | 具体约束 | 错误码 | 错误提示 |
    |--------|----------|----------|--------|----------|
    | `field1` | 非空 | - | 400001 | 字段1不能为空 |
    | `field2` | 格式 | 正则：^\d+$ | 400002 | 字段2格式不正确 |
- **异常场景**：
    | 场景 | 错误码 | 错误提示 | 处理建议 |
    | :--- | :--- | :--- | :--- |
    | 找不到数据 | 10010 | 数据不存在 | 检查ID是否正确 |
- **响应（操作类）**：
    ```json
    {
      "code": "200",
      "msg": "操作成功",
      "data": null
    }
    ```
- **响应（查询类）**：
    ```json
    {
      "code": "200",
      "msg": "success",
      "data": { ... }
    }
    ```
- **响应（分页查询）**：
    ```json
    {
      "code": "200",
      "msg": "success",
      "data": {
        "total": 100,
        "list": [{ ... }]
      }
    }
    ```
- **错误响应**：
    ```json
    {
      "code": "10010",
      "msg": "数据不存在",
      "data": null
    }
    ```

---

## 四、 现有接口参考 (Based on 后端功能API.md)

### 商品添加 API (示例)
- **接口**：`POST /api/v1/products`
- **版本**：v1
- **权限**：需要登录 (`@PreAuthorize("isAuthenticated()")`)
- **事务**：是
- **幂等性**：是（防止重复添加）
- **并发控制**：否
- **核心逻辑**：
    1. 校验 skuCode 唯一性
    2. 创建商品记录
    3. 初始化库存
- **请求体**：
    ```json
    {
      "skuCode": "SKU123",
      "skuName": "iPhone 15",
      "brand": "Apple",
      "price": "5999.00",
      "totalStock": 100
    }
    ```
- **请求体字段**：
    | 字段名 | 类型 | 必填 | 约束 | 错误码 | 错误提示 |
    | :--- | :--- | :--- | :--- | :--- | :--- |
    | `skuCode` | String | 是 | max:50 | 400001 | 商品编码不能为空 |
    | `skuName` | String | 是 | max:100 | 400001 | 商品名称不能为空 |
    | `brand` | String | 是 | max:50 | 400001 | 品牌不能为空 |
    | `price` | String | 是 | >0, 2位小数 | 400003 | 价格必须大于0 |
    | `totalStock` | Integer | 是 | >=0 | 400003 | 库存必须大于等于0 |
- **验证规则（结构化）**：
    | 字段名 | 规则类型 | 具体约束 | 错误码 | 错误提示 |
    |--------|----------|----------|--------|----------|
    | `skuCode` | 唯一性 | 查询 product 表 | 30030 | 商品编码已存在 |
    | `price` | 数值 | > 0 | 400003 | 价格必须大于0 |
    | `totalStock` | 数值 | >= 0 | 400003 | 库存必须大于等于0 |
- **异常场景**：
    | 场景 | 错误码 | 错误提示 | 处理建议 |
    | :--- | :--- | :--- | :--- |
    | 商品编码已存在 | 30030 | 商品编码已存在，请使用其他编码 | 提示用户更换编码 |
    | 参数校验失败 | 00001 | 参数校验失败 | 检查必填字段 |
- **响应（操作类）**：
    ```json
    {
      "code": "200",
      "msg": "商品添加成功",
      "data": null
    }
    ```
- **错误响应**：
    ```json
    {
      "code": "30030",
      "msg": "商品编码已存在，请使用其他编码",
      "data": null
    }
    ```
