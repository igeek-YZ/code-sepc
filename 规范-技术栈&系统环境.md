# 技术栈 & 系统环境

## 一、技术栈要求
- 前端框架：Vue 3 + Element Plus 
- 后端框架：Spring Boot + mybatis-plus + jwt + feign
- 数据库：MySQL 5.7+
- 缓存：Redis 6.0+
- 验证码服务：邮件验证码服务,短信验证码服务
- api接口：RESTful API

## 二、系统环境要求
- 操作系统：Linux CentOS 7+ 
- Java版本：JDK 1.8+
- Node.js版本：v16.18.0+ 
- MySQL版本：5.7+
- Nginx版本：1.16.0+

## 三、代码规范

- **架构设计规范**：
  - **分层架构**：项目采用模块化分层架构，明确各模块职责，禁止循环依赖。
  - **模块划分**：
    1.  **common-module (公共组件模块)**：
        - 包含全局常量、工具类 (Utils)、全局异常处理 (GlobalExceptionHandler)、统一响应对象 (Result)、AOP 切面 (日志/权限) 等。
        - 被所有其他模块依赖。
    2.  **dal-module (数据访问层模块)**：
        - **职责**：负责所有与数据库交互的逻辑。
        - **包含内容**：Entity (实体类)、Mapper (MyBatis接口)、XML 映射文件、DAL Service (对 Mapper 的简单封装，提供原子性的 CRUD 操作)。
        - **对外暴露**：仅暴露 DAL Service 接口，屏蔽底层数据库实现细节。
        - **依赖**：依赖 common-module。
    3.  **third-party-module (第三方服务模块)**：
        - **职责**：集成外部服务 (如短信、邮件、文件存储、支付等)。
        - **包含内容**：Feign Client、SDK 集成代码、适配器模式实现的 Service。
        - **对外暴露**：统一的 Service 接口 (如 `SmsService`)，隐藏具体供应商实现。
        - **依赖**：依赖 common-module。
    4.  **biz-module (业务功能模块)**：
        - **职责**：核心业务逻辑实现 (如 `order-service`, `user-service`)。
        - **包含内容**：Controller (接口层)、Biz Service (业务逻辑层)、DTO/VO (数据传输对象)。
        - **依赖**：依赖 common-module, dal-module, third-party-module。
        - **调用关系**：Biz Service 调用 DAL Service 进行数据读写，调用 Third-party Service 使用外部能力，禁止 Biz Service 直接调用 Mapper。

  - **工程目录结构示例**：
    ```text
    project-root
    ├── common-module
    │   └── src/main/java/com/example/common
    │       ├── config      // 全局配置 (WebMvcConfig, MybatisPlusConfig)
    │       ├── constant    // 全局常量 (ResultCode, RedisKey)
    │       ├── exception   // 全局异常 (GlobalExceptionHandler)
    │       ├── model       // 统一对象 (Result, PageResult)
    │       └── utils       // 工具类 (DateUtil, JwtUtil)
    ├── dal-module
    │   └── src/main/java/com/example/dal
    │       ├── entity      // 数据库实体 (UserEntity)
    │       ├── mapper      // MyBatis 接口 (UserMapper)
    │       └── service     // 基础 CRUD 服务 (UserDalService)
    ├── third-party-module
    │   └── src/main/java/com/example/thirdparty
    │       ├── client      // Feign 客户端 (SmsClient)
    │       └── service     // 适配服务实现 (SmsServiceImpl)
    ├── biz-module
    │   └── src/main/java/com/example/biz
    │       ├── controller  // 接口层 (UserController)
    │       ├── service     // 业务逻辑层 (UserService)
    │       └── model       // 数据模型
    │           ├── dto     // 数据传输对象 (UserCreateReq)
    │           └── vo      // 视图对象 (UserResp)
    └── ...
    ```

- **通用设计**：
  - **核心类骨架 (Skeleton Code)**：
    - **统一响应对象 (`Result<T>`)**：
      ```java
      @Data
      public class Result<T> implements Serializable {
          private String code;
          private String msg;
          private T data;
          
          public static <T> Result<T> success(T data) { ... }
          public static <T> Result<T> error(String code, String msg) { ... }
      }
      ```
    - **数据库基础实体 (`BaseEntity`)**：
      ```java
      @Data
      public abstract class BaseEntity implements Serializable {
          @TableId(type = IdType.AUTO)
          private Long id;
          
          @TableField(fill = FieldFill.INSERT)
          private LocalDateTime createTime;
          
          @TableField(fill = FieldFill.INSERT_UPDATE)
          private LocalDateTime lastModifiedTime;
          
          @TableLogic
          private Integer isDeleted; // 0:未删, 1:已删
      }
      ```
  - **代码模块化设计**：每个模块负责特定的功能，抽象出模块 Service 对外提供方法便于扩展，模块之间解耦。
  - **Lombok 使用**：DTO/VO/Entity 统一使用 `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`。
  - **枚举与常量**：
    - 业务状态值必须定义 Enum，实现 `IEnum<Integer>` 接口（MyBatis-Plus）。
    - 常量类命名为 `XxxConst` (如 `RedisConst`), 字段使用 `public static final`。
  
- **日志规范**：
  - **工具选择**：必须使用 SLF4J 接口配合 Logback 实现。禁止使用 `System.out` 或 `e.printStackTrace()`。
  - **注解使用**：类上统一使用 Lombok 的 `@Slf4j` 注解。
  - **日志打印场景与格式**：
    - **Service 方法入口**：
      - 必须打印。
      - 格式：`log.info("Method started: class={}, method={}, params={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(params));`
    - **Service 方法出口**：
      - 建议打印（关键业务必须打印）。
      - 格式：`log.info("Method finished: class={}, method={}, result={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(result));`
    - **异常捕获**：
      - 必须打印堆栈信息。
      - 格式：`log.error("Method failed: class={}, method={}, params={}, error={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(params), e.getMessage(), e);`
    - **逻辑分支**：
      - 关键的 if/else 或 switch 分支必须打印日志记录决策路径。
  - **敏感信息脱敏**：
    - 在打印日志（尤其是 JSON 序列化）时，必须对手机号、身份证、密码等敏感字段进行脱敏处理（建议使用 Fastjson Filter 或 Logback Masking）。


- **事务与并发控制规范**：
  - **事务管理**：
    - **注解使用**：必须使用 `@Transactional(rollbackFor = Exception.class)`，禁止使用默认配置（仅回滚 RuntimeException）。
    - **范围控制**：仅在 Service 层方法上添加事务，禁止在 Controller 层或耗时操作（如 RPC、文件 IO）上加事务。
    - **失效场景**：注意自调用失效问题，必须通过 `AopContext.currentProxy()` 调用或注入自身 Bean。
  - **并发控制**：
    - **分布式锁**：使用 Redisson 实现。
    - **锁粒度**：Key 必须包含业务唯一标识（如 `lock:order:pay:{orderId}`）。
    - **使用模式**：必须使用 try-finally 块释放锁。
      ```java
      RLock lock = redissonClient.getLock("key");
      if (lock.tryLock()) {
          try {
              // 业务逻辑
          } finally {
              lock.unlock();
          }
      }
      ```

- **注释规范**：
  - Service 接口及实现类方法必须添加 Javadoc 注释，包含 `@param`, `@return`, `@throws`。
  - Controller 方法必须添加 Javadoc 注释，说明接口用途。
  - Mapper 方法必须添加 Javadoc 注释。

- **数据持久层 (Mapper)**：
  - 继承 MyBatis-Plus 的 `BaseMapper<T>` 接口。
  - 涉及到分页查询时，必须使用ID作为排序分页查询的依据, 确保分页查询的结果是连续的。
  - 必须提供的自定义 CRUD 方法 (如果 BaseMapper 不满足): 
    - `insertBatch(List<T> list)`
    - `selectByCondition(T query)`
    - `selectOrderByIdPage(T query, Long lastId, Integer limit)`
    - `selectOrderByIdList(T query, Long lastId, Integer limit)`
    - `updateById(T entity)`
    - `deleteById(Long id)`

- **API 接口规范**：
  - **请求日志 (AOP 实现)**：使用 AOP 切面记录所有 API 接口的请求和响应日志，格式为 CURL:。
    ```text
      HTTP_REQ -> curl -X POST \
        http://localhost:8080/api/register \
        -H 'Content-Type: application/json' \
        -d '{...}'
    ```
  - **响应格式**：统一使用 `Result<T>` 泛型类封装。
    ```json
    {
      "code": 200,
      "msg": "success",
      "data": { ... }
    }
    ```
  - **状态码定义**：
    - 200: 成功
    - 400: 参数错误
    - 401: 未认证 (Token 无效/过期)
    - 403: 无权限
    - 404: 资源未找到
    - 429: 请求过频
    - 500: 系统内部错误
  - **API 文档**：使用 Knife4j (OpenAPI 3) 注解。
    - Controller 类使用 `@Tag(name = "xxx")`
    - 方法使用 `@Operation(summary = "xxx")`
    - 参数使用 `@Parameter(description = "xxx")`

- **异常处理规范**：
  - **自定义异常**：
    - 创建 `BusinessException` 继承 `RuntimeException`。
    - 必须包含字段：`Integer code` (错误码), `String message` (错误信息)。
  - **全局异常处理 (GlobalExceptionHandler)**：
    - 使用 `@RestControllerAdvice` 注解。
    - **处理逻辑**：
      - 捕获 `BusinessException` -> 返回 `Result.error(e.getCode(), e.getMessage())`。
      - 捕获 `MethodArgumentNotValidException` (参数校验失败) -> 返回 `Result.error(400, "参数校验失败: " + fieldError.getDefaultMessage())`。
      - 捕获 `Exception` (兜底) -> 打印 Error 日志 -> 返回 `Result.error(500, "系统繁忙，请稍后重试")`。
  - **抛出原则**：
    - 业务层 (Service) 遇到逻辑错误（如库存不足、用户不存在），**必须**抛出 `BusinessException`，禁止直接返回 null 或错误码对象。
    - 禁止在 Controller 层捕获异常（除非为了特殊降级处理），应统一由全局异常处理器接管。

- **第三方服务集成**：
  - 独立模块 (如 `third-party-sms`)。
  - 定义统一接口 (如 `SmsService`) 继承 IApiService，实现类与接口同名，后缀为 `Impl`，如 `SmsServiceImpl`中封装具体逻辑, IApiService 代码如下：
    ```java
    public interface IApiService {
    /**
     * 请求 指定业务 服务器
     *
     * @param request 请求
     * @param <Resp>  响应
     */
    <Resp extends ApiResponse> Resp request(ApiRequest<Resp> request) throws ApiException;
    /**
     * 请求 指定业务 服务器
     *
     * @param trackId 追踪ID
     * @param request 请求
     * @param <Resp>  响应
     */
    <Resp extends ApiResponse> Resp request(String trackId, ApiRequest<Resp> request) throws ApiException;
    }
    ```
    ```java
    public interface ApiRequest<resp extends ApiResponse> extends Serializable {
    /**
     * 请求的路径
     */
    String requestMappingUrl();
    /**
     * 是否对请求body进行加密处理
     */
    default boolean ciphertextEnable() {
        return false;
    }
    /**
     * 请求的响应结构体
     */
    Class<resp> respClass();
    /**
     * 请求所带的token
     */
    default String accessToken(){
        return null;
    }
    }
    ```
    ```java
    public interface ApiResponse extends Serializable {
    }
    ```
  - 定义统一HTTP调用方式使用 **Feign Client**，实现类添加 `@FeignClient` 注解。
  - 定义统一HTTP调用方法：
    ```java
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    String postByURI(URI uri, @RequestHeader("trackId") String trackId, @RequestBody Object body);
    ```
  - **Feign 日志规范 (CURL)**：
    - **强制要求**：所有 Feign 客户端必须配置自定义 `Logger` 实现类 FeignLogger，将请求日志格式化为 `curl` 命令。
    - **日志级别**：Feign Client 配置必须设为 `Logger.Level.FULL`。
    - **请求日志 (`logRequest`)**：
       - 必须包含：Method, URL, Headers, Body。
       - 格式要求：使用多行 `curl` 命令格式，每行一个参数，使用 `\` 换行，确保可读性和直接复制执行。
       - 示例：
         ```bash
         curl -X POST 'https://api.example.com/v1/users' \
           -H 'Content-Type: application/json' \
           -H 'Authorization: Bearer xxxxx' \
           -d '{
             "name": "test",
             "age": 18
           }'
         ```
     - **响应日志 (`logAndRebufferResponse`)**：
      - 必须包含：HTTP Status, 耗时 (Latency), Response Body。
      - 示例：`FEIGN_RESP -> curl -X POST 'http://10.0.0.1/api/sms' [status:200] (120ms) body: {"code":200,"msg":"success"}`
    - **异常日志**：
      - 当 Feign 调用抛出异常时，必须在 ERROR 级别日志中打印原始请求的 CURL 命令。

- **异步处理与事件驱动规范**：
  - **核心原则**：
    - 接口响应时间超过 500ms 的核心提交操作，必须采用异步处理。
    - 核心业务流程中的副作用（Side Effects，如发通知、统计）必须通过事件解耦。
  - **技术实现**：
    - **实现方式**：使用 Spring Event (`ApplicationEventPublisher`) 配合 `@EventListener` 和 `ThreadPoolTaskExecutor` 实现进程内解耦。
    - **发布事件**：
      ```java
      @Autowired
      private ApplicationEventPublisher eventPublisher;
      @Autowired
      private ThreadPoolTaskExecutor taskExecutor;

      public void publishEvent(DelayHandleTaskEvent event, boolean isAsync) {
        if (isAsync) {
            taskExecutor.execute(() -> eventPublisher.publishEvent(event));
        } else {
            eventPublisher.publishEvent(event);
        }
      }
      ```
    - **监听事件**：
      ```java
      @Component
      public class DelayHandleTaskListener {
          @EventListener
          public void handleDelayHandleTaskEvent(DelayHandleTaskEvent event) {
              // 异步处理逻辑
          }
      }
      ```
    - **强制要求**：
      - 必须配置自定义线程池 (TaskExecutor)，禁止使用 Spring 默认的 SimpleAsyncTaskExecutor。
      - 事件类名必须以 `Event` 结尾 (如 `OrderCreatedEvent`)。
    - **分布式异步**：在跨服务解耦时使用 MQ/Redis。
  - **API 交互模式**：
    - **提交接口**：
      - 收到请求后，生成 `taskId`，存入 Redis/DB 初始化状态为 `PENDING`。
      - 通过 `eventPublisher.publishEvent(...)` 触发异步处理。
      - 立即返回响应：`{ "code": 200, "data": { "taskId": "t_1001", "status": "PENDING" } }`。
    - **结果轮询接口**：
      - 前端轮询 `GET /api/async-tasks/{taskId}` (建议间隔 1s/3s/5s 退避)。
      - 响应结构：
        ```json
        {
          "code": 200,
          "data": {
            "taskId": "t_1001",
            "status": "SUCCESS", // PENDING, PROCESSING, SUCCESS, FAILED
            "progress": 100,     // 可选：进度百分比
            "result": { ... },   // 成功时的业务数据
            "errorMsg": null     // 失败时的错误信息
          }
        }
        ```
  - **异常与兜底**：
    - 异步方法内部**必须** try-catch 所有异常。
    - 捕获异常后：1. 打印 ERROR 日志；2. 将任务状态更新为 `FAILED`；3. 记录错误信息。

- **前端代码规范**：
  - **目录结构**：
    - `src/views`: 页面视图组件
    - `src/components`: 全局通用组件
    - `src/hooks`: 组合式 API (Composables)
    - `src/store`: 状态管理 (推荐 Pinia)
    - `src/api`: 后端接口封装
  - **命名规范**：
    - 组件文件：使用大驼峰命名 (PascalCase)，如 `UserProfile.vue`。
    - 目录命名：使用小写短横线 (kebab-case)，如 `user-profile`。
  - **网络请求**：
    - 统一封装 Axios，拦截器中处理 `Result<T>` 响应结构。
    - API 模块与后端 Controller 对应，方法名保持语义一致。

- **数据库设计规范**：
  - **命名规范**：
    - 表名：使用 `t_` 前缀，如 `t_user`。
    - 字段名：使用下划线分隔 (snake_case)，如 `user_name`。
    - **索引命名**：
      - 普通索引：`idx_{字段名}` (如 `idx_user_name`)
      - 唯一索引：`uk_{字段名}` (如 `uk_phone`)
      - 组合索引：`idx_{字段1}_{字段2}`
  - **基础约束**：
    - **字符集**：统一使用 `utf8mb4`，排序规则 `utf8mb4_general_ci`。
    - **外键**：禁止使用物理外键，关联关系在业务代码中维护。
    - **存储引擎**：必须使用 InnoDB。
  - **通用字段**：每张表必须包含：
    - `id` (主键, BigInt, 自增/雪花算法)
    - `create_time` (创建时间, timestamp, default CURRENT_TIMESTAMP)
    - `last_modified_time` (更新时间, timestamp, default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)
    - `status` (状态值, TinyInt, 1:正常, 0:禁用)
    - `is_deleted` (逻辑删除, TinyInt, 0:未删, 1:已删)
  - **数据类型**：
    - 金额：使用 `Decimal(10, 4)`。
    - 布尔值：使用 `TinyInt` (0/1)。
    - 枚举值：使用 `TinyInt` 或 `Int`。

- **Git 提交与版本管理**：
  - **Commit Message**：采用 Conventional Commits 规范。
    - `feat`: 新功能
    - `fix`: 修复 Bug
    - `docs`: 文档变更
    - `style`: 代码格式调整 (不影响逻辑)
    - `refactor`: 代码重构
    - `chore`: 构建/工具链变动
  - **分支管理**：
    - `main/master`: 主分支，随时可发布。
    - `develop`: 开发分支。
    - `feature/*`: 功能分支，从 main/master 新建，完成后合并到 develop。

- **配置文件规范**：
  - **命名规范**：
    - 配置文件：`application-{env}.yml`
    - 配置项：使用 kebab-case (如 `custom-thread-pool.core-size`)。
  - **配置结构**：
    ```yaml
    server:
      port: 8080
    spring:
      application:
        name: xxx-service
      datasource: ...
      redis: ...
    # 自定义配置
    app:
      sms:
        enabled: true
      thread-pool:
        core-size: 10
    ```
  - **多环境配置**：
    - `application.yml`: 公共配置
    - `application-sit.yml`: 测试环境
    - `application-prod.yml`: 生产环境
  - **敏感信息**：
    - 生产环境密码、密钥禁止明文提交到代码库，应通过环境变量或 CI/CD 注入。

- **测试规范**：
  - **技术选型**：JUnit 5 + Spring Boot Test + H2/Mockito。
  - **单元/集成测试**：
    - **注解使用**：
      - 使用 `@SpringBootTest` 启动完整上下文（适用于验证 Service与 DB/Cache 的集成逻辑）。
      - 配合 `@Transactional` 确保测试数据回滚，不污染数据库。
    - **Mock 策略**：
      - 外部服务（如 Feign Client）必须使用 `@MockBean` 进行模拟，隔离外部依赖。
    - **代码示例**：
      ```java
      @SpringBootTest
      @Transactional // 自动回滚事务
      @Slf4j
      class UserServiceTest {
          @Autowired
          private UserService userService;
          
          @MockBean // Mock 外部短信服务
          private SmsService smsService;

          @Test
          void should_create_user_success() {
              // Arrange
              UserCreateReq req = new UserCreateReq("test_user");
              when(smsService.sendCode(anyString())).thenReturn(true);
              
              // Act
              Long userId = userService.createUser(req);
              
              // Assert
              assertThat(userId).isNotNull();
              // 验证 DB 是否写入 (Integration Test 优势)
              UserVO user = userService.getUserById(userId);
              assertThat(user.getUsername()).isEqualTo("test_user");
          }
      }
      ```
  - **测试覆盖率**：核心业务模块行覆盖率建议 > 60%。

## 四、非功能需求
- **安全性**：
  - 验证码有效期5分钟，防止暴力破解
  - 用户认证使用JWT token，token有效期2小时
  - 敏感数据传输采用HTTPS加密
  - 数据库密码采用加密存储
  - 对应用户表的重要信息（如身份证/统一社会信用代码、联系人、手机号、邮箱）采用AES加密存储
- **性能要求**：
  - 页面加载时间≤2秒
  - API响应时间≤500ms
- **兼容性**：
  - 支持主流浏览器（Chrome、Firefox、Safari、Edge）
  - 适配1024px以上屏幕分辨率
- **可维护性**：
  - 代码模块化设计，便于扩展，模块之间解耦
- **用户体验**：
  - 界面简洁、操作 intuit ive
  - 提供清晰的错误提示和提示信息
