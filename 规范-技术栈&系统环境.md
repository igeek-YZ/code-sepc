# 技术栈 & 系统环境

## 目录
- [一、技术栈要求](#一技术栈要求)
- [二、系统环境要求](#二系统环境要求)
- [全局定义](#全局定义)
- [三、代码规范](#三代码规范)
  - [架构设计规范](#架构设计规范)
  - [通用设计](#通用设计)
  - [命名规范对照表](#命名规范对照表)
  - [Redis Key 命名规范](#redis-key-命名规范)
  - [日志规范](#日志规范)
  - [事务与并发控制规范](#事务与并发控制规范)
  - [注释规范](#注释规范)
  - [代码示例（正确 vs 错误）](#代码示例正确-vs-错误)
  - [参数校验规范](#参数校验规范)
  - [数据持久层 (Mapper)](#数据持久层-mapper)
  - [异常处理规范](#异常处理规范)
  - [第三方服务集成](#第三方服务集成)
  - [异步处理与事件驱动规范](#异步处理与事件驱动规范)
  - [前端代码规范](#前端代码规范)
  - [数据库设计规范](#数据库设计规范)
  - [Git 提交与版本管理](#git-提交与版本管理)
  - [配置文件规范](#配置文件规范)
  - [测试规范](#测试规范)
  - [代码模板（快速生成）](#代码模板快速生成)
- [四、非功能需求](#四非功能需求)

## 一、技术栈要求
- 前端框架：Vue 3 + Element Plus 
- 后端框架：Spring Boot + mybatis-plus + jwt + feign
- 数据库：MySQL 5.7+
- 缓存：Redis 6.0+
- 验证码服务：邮件验证码服务,短信验证码服务
- api接口：RESTful API

## 二、系统环境要求
- 操作系统：Linux CentOS 7+ 
- Java版本：JDK 1.8+
- Node.js版本：v16.18.0+ 
- MySQL版本：5.7+
- Nginx版本：1.16.0+

## 全局定义
> **说明**：以下变量为项目全局定义，在整个文档中统一使用，请根据实际项目替换。
> 
> | 变量 | 说明 | 示例值 |
> |------|------|--------|
> | `{{PROJECT_NAME}}` | 项目名称（英文） | `mall`, `shop`, `ecommerce` |
> | `{{COMPANY_NAME}}` | 公司/组织名称（英文） | `mycompany`, `acme` |
> | `{{PACKAGE_BASE}}` | 基础包名 | `com.mycompany.mall` |
> | `{{SERVICE_NAME}}` | 服务名称 | `mall-service` |
> | `{{REDIS_PREFIX}}` | Redis Key 前缀 | `mall:` |
> | `{{TABLE_PREFIX}}` | 数据库表前缀 | `t_mall_` |
> | `{{SERVER_IP}}` | 目标服务器 IP | `192.168.1.100` |
> | `{{SSH_PORT}}` | SSH 端口 | `22` |
> | `{{SSH_USER}}` | SSH 用户名 | `root` |
> | `{{SSH_PASSWORD}}` | SSH 密码/密钥路径 | `123456` 或 `/root/.ssh/id_rsa` |
> | `{{DEPLOY_ROOT}}` | 部署根路径 | `/opt/{{PROJECT_NAME}}` |
> | `{{DB_URL}}` | 数据库连接地址 | `jdbc:mysql://127.0.0.1:3306/db_name` |
> | `{{DB_USER}}` | 数据库用户名 | `root` |
> | `{{DB_PASSWORD}}` | 数据库密码 | `123456` |
> | `{{REDIS_HOST}}` | Redis 地址 | `127.0.0.1` |
> | `{{REDIS_PORT}}` | Redis 端口 | `6379` |
> | `{{REDIS_PASSWORD}}` | Redis 密码 | `password` |
> | `{{DOMAIN_OR_PORT}}` | 域名或公网端口 | `www.example.com` 或 `80` |
> | `{{BACKEND_CODE_DIR}}` | 后端源码存放目录 | `code/backend` |
> | `{{FRONTEND_CODE_DIR}}` | 前端源码存放目录 | `code/frontend` |

## 三、代码规范

- **架构设计规范**：
  - **分层架构**：项目采用模块化分层架构，明确各模块职责，禁止循环依赖。
  - **模块划分**：
    1.  **common-module (公共组件模块)**：
        - 包含全局常量、工具类 (Utils)、全局异常处理 (GlobalExceptionHandler)、统一响应对象 (Result)、AOP 切面 (日志/权限) 等。
        - 被所有其他模块依赖。
        - 路径：`common-module/src/main/java/{{PACKAGE_BASE}}/common`
    2.  **dal-module (数据访问层模块)**：
        - **职责**：负责所有与数据库交互的逻辑。
        - **包含内容**：Entity (实体类)、Mapper (MyBatis接口)、XML 映射文件、DAL Service (对 Mapper 的简单封装，提供原子性的 CRUD 操作)。
        - **对外暴露**：仅暴露 DAL Service 接口，屏蔽底层数据库实现细节。
        - **依赖**：依赖 common-module。
        - 路径：`dal-module/src/main/java/{{PACKAGE_BASE}}/dal`
    3.  **third-party-module (第三方服务模块)**：
        - **职责**：集成外部服务 (如短信、邮件、文件存储、支付等)。
        - **包含内容**：Feign Client、SDK 集成代码、适配器模式实现的 Service。
        - **对外暴露**：统一的 Service 接口 (如 `SmsService`)，隐藏具体供应商实现。
        - **依赖**：依赖 common-module。
        - 路径：`third-party-module/src/main/java/{{PACKAGE_BASE}}/thirdparty`
    4.  **业务模块 (biz-xxx-module)**：
        - **职责**：核心业务逻辑实现，按领域划分为独立子模块。
        - **模块列表**：
          | 模块名 | 领域 | 职责 | 路径 |
          |--------|------|------|------|
          | admin-account-module | 账号模块 | 用户登录、注册、认证、Token管理、权限控制 | `admin-account-module/...` |
          | admin-user-module | 用户模块 | 用户信息管理、会员等级、地址管理 | `admin-user-module/...` |
          | admin-product-module | 商品模块 | 商品发布、类目管理、商品详情、商品评价 | `admin-product-module/...` |
          | admin-price-module | 价格模块 | 商品定价、价格策略、成本价管理 | `admin-price-module/...` |
          | admin-inventory-module | 库存模块 | 库存管理、库存预警、库存日志 | `admin-inventory-module/...` |
          | admin-order-module | 订单模块 | 订单创建、支付、取消、关闭、发货、收货 | `admin-order-module/...` |
          | admin-aftersales-module | 售后单模块 | 退款、退货、换货、售后审核 | `admin-aftersales-module/...` |
          | admin-guide-module | 导购模块 | 导购员管理、导购业绩、导购跟踪 | `admin-guide-module/...` |
          | admin-promotion-module | 促销模块 | 优惠券、满减、秒杀、团购、拼团 | `admin-promotion-module/...` |
          | admin-marketing-module | 营销模块 | 活动管理、推荐算法、用户触达 | `admin-marketing-module/...` |
          | frontend-cart-module | 购物车模块 | 购物车CRUD、购物车合并 | `frontend-cart-module/...` |
          | frontend-order-module | 订单模块 | 订单创建、支付、取消、关闭、发货、收货 | `frontend-order-module/...` |
          | frontend-product-module | 商品模块 | 商品浏览、搜索、详情、评价 | `frontend-product-module/...` |
          | frontend-user-module | 用户模块 | 用户信息、收货地址 | `frontend-user-module/...` |
        - **端区分**：
          - **B端 (admin-xxx-module)**：面向商家/管理员的管理后台接口
            - Controller 路径：`/admin/{module}/`，如 `/admin/order/`, `/admin/product/`
            - 命名规范：`XxxAdminController`
          - **C端 (frontend-xxx-module)**：面向消费者的移动端/PC端接口
            - Controller 路径：`/api/{module}/`，如 `/api/order/`, `/api/cart/`
            - 命名规范：`XxxApiController`
          - **开放API (biz-open-api-module)**：面向第三方的开放接口
            - Controller 路径：`/open/{module}/`，如 `/open/order/`
            - 命名规范：`XxxOpenController`
        - **调用关系**：
          - Biz Service 调用 DAL Service 进行数据读写
          - Biz Service 调用 Third-party Service 使用外部能力
          - 禁止 Biz Service 直接调用 Mapper
        - **依赖**：依赖 common-module, dal-module, third-party-module
    5.  **hub-module (三方回调接口模块)**：
        - **职责**：接收第三方系统的回调通知，使用统一接口 + 适配器模式处理
        - **接口路径规则**：`/hub/{eventType}/{platform}/{tenantId}`
          | 参数 | 说明 | 示例 |
          |------|------|------|
          | `{eventType}` | 业务事件类型 | `pay`, `logistics`, `sms` |
          | `{platform}` | 平台标识 | `wechat`, `alipay`, `sf`, `yunpian` |
          | `{tenantId}` | 租户ID | `t_1001`, `tenant_001` |
        - **接口设计**：
          - 每个业务事件类型只保留 **一个统一接口**
          - 入参为 `String` 类型（原始报文），通过 `@RequestParam` 获取 Query 参数，`@RequestBody` 获取 Body 参数
          - 使用平台适配器解析为统一数据结构
          - 抛出租户业务事件，由业务模块处理
        - **接口示例**：
          | 业务类型 | 接口路径 | 用途 |
          |----------|----------|------|
          | 支付 | `/hub/pay/wechat/t_1001` | 微信支付回调 |
          | 支付 | `/hub/pay/alipay/t_1001` | 支付宝回调 |
          | 物流 | `/hub/logistics/sf/t_1001` | 顺丰物流回调 |
          | 短信 | `/hub/sms/yunpian/t_1001` | 云片短信回调 |
        - **适配器接口定义**：
          ```java
          public interface HubAdapter {
              /**
               * 获取业务事件类型
               */
              String eventType();
              
              /**
               * 获取适配器支持的平台
               */
              String platform();
              
              /**
               * 处理回调
               *
               * @param queryParams Query 参数 map
               * @param rawData 原始报文
               * @param tenantId 租户ID
               * @return 响应数据（String/XML/JSON等）
               */
              HubCallbackData parse(String tenantId, String eventType, String platform, Map<String, String> queryParams, String rawData);

              /**
               * 构建回调数据
               *
               * @param tenantId 租户ID
               * @param eventType 事件类型
               * @param platform 平台标识
               * @param data 回调数据
               * @return 响应数据（String/XML/JSON等）
               */
              Object buildCallbackData(String tenantId, String eventType, String platform, HubCallbackData data);
          }
          
          /**
           * 统一回调数据结构
           */
          @Data
          @Builder
          @NoArgsConstructor
          @AllArgsConstructor
          public class HubCallbackData implements Serializable {
              private String tenantId;
              private String eventType;
              private String platform;
              private Map<String, Object> data;
              private LocalDateTime callbackTime;
              private boolean success;
              private String errorMsg;
          }
          
          /**
           * 回调事件基类
           */
          @Data
          @AllArgsConstructor
          public class HubCallbackEvent {
              private HubCallbackData data;
          }
          ```
        - **统一 Controller 实现**：
          ```java
          @Slf4j
          @RestController
          @RequestMapping("/hub")
          public class HubController {
              private final ApplicationEventPublisher eventPublisher;
              private final HubAdapterFactory hubAdapterFactory;
              
              /**
               * 统一回调入口
               *
               * @param eventType 业务事件类型 (pay/logistics/sms)
               * @param platform  平台标识 (wechat/alipay/sf)
               * @param tenantId  租户ID
               * @param queryParams 所有 Query 参数
               * @param rawData   原始报文 (Request Body)
               * @return 响应
               */
              @PostMapping("/{eventType}/{platform}/{tenantId}")
              public Object callback(
                      @PathVariable String eventType,
                      @PathVariable String platform,
                      @PathVariable String tenantId,
                      @RequestParam Map<String, String> queryParams,
                      @RequestBody String rawData) {
                  log.info("callback[{}][{}][{}] queryParams={}", eventType, platform, tenantId, JSON.toJSONString(queryParams));
                  
                  // 1. 获取适配器
                  HubAdapter adapter = hubAdapterFactory.getAdapter(eventType, platform);
                  if (adapter == null) {
                      log.error("callback[{}][{}][{}] adapter not found", eventType, platform, tenantId);
                      return "adapter not found";
                  }
                  
                  try {
                      // 2. 处理回调，返回响应数据
                        HubCallbackData result = adapter.parse(tenantId, eventType, platform, queryParams, rawData);
                      
                      log.info("callback[{}][{}][{}] success", eventType, platform, tenantId);

                      eventPublisher.publishEvent(new HubCallbackEvent(data));
                      return adapter.buildCallbackData(tenantId, eventType, platform, result);
                      
                  } catch (Exception e) {
                      log.error("callback[{}][{}][{}] error: {}", eventType, platform, tenantId, e.getMessage(), e);
                      return adapter.buildCallbackData(tenantId, eventType, platform, HubCallbackData.builder()
                              .success(false)
                              .errorMsg(e.getMessage())
                              .build());
                  }
              } 
          }
          ```
        - **适配器工厂**：
          ```java
          @Component
          public class HubAdapterFactory {
              private final Map<String, HubAdapter> adapters = new ConcurrentHashMap<>();
              
              @PostConstruct
              public void init() {
                  Map<String, HubAdapter> beans = applicationContext.getBeansOfType(HubAdapter.class);
                  beans.values().forEach(adapter -> {
                      String key = adapter.bizType() + ":" + adapter.platform();
                      adapters.put(key, adapter);
                  });
              }
              
              public HubAdapter getAdapter(String bizType, String platform) {
                  return adapters.get(bizType + ":" + platform);
              }
          }
          ```
        - **强制要求**：
          - 每个业务类型只保留 **一个 Controller 接口**
          - 入参必须为 `String` 类型（原始报文）
          - 必须通过 `@RequestParam` 获取 Query 参数，`@RequestBody` 获取 Body
          - 必须使用适配器模式解析不同平台数据
          - 必须抛出租户业务事件（`HubCallbackEvent` 或业务特定事件）
          - 必须记录完整回调日志
          - 必须返回第三方要求的响应格式
        - **依赖**：依赖 common-module, third-party-module
    6.  **task-module (后台任务模块)**：
        - **职责**：定时任务、消息队列消费者、异步任务处理
        - **任务分类**：
          | 任务类型 | 命名规则 | 示例 |
          |----------|----------|------|
          | 定时任务 | `XxxScheduleTask` | `OrderTimeoutCloseScheduleTask` |
          | 消息消费者 | `XxxMqConsumer` | `OrderCreatedMqConsumer` |
          | 异步任务 | `XxxAsyncTask` | `InventorySyncAsyncTask` |
        - **任务存放路径**：`task-module/src/main/java/{{PACKAGE_BASE}}/task/{模块名}/`
          | 模块 | 路径 |
          |------|------|
          | 订单任务 | `task/order/` |
          | 库存任务 | `task/inventory/` |
          | 营销任务 | `task/marketing/` |
          | 结算任务 | `task/settlement/` |
          | 数据任务 | `task/data/` |
        - **依赖**：依赖 common-module, dal-module, admin-xxx-module, frontend-xxx-module
        - **强制要求**：
          - 所有任务必须实现幂等性
          - 必须配置合理的重试机制和失败告警
          - 必须记录任务执行日志

  - **工程目录结构示例**：
    ```text
    project-root
    ├── common-module
    │   └── src/main/java/{{PACKAGE_BASE}}/common
    │       ├── config      // 全局配置
    │       ├── constant    // 全局常量
    │       ├── exception   // 全局异常
    │       ├── model       // 统一对象
    │       └── utils       // 工具类
    ├── dal-module
    │   └── src/main/java/{{PACKAGE_BASE}}/dal
    │       ├── entity      // 数据库实体
    │       ├── mapper      // MyBatis 接口
    │       └── service     // DAL Service
    ├── third-party-module
    │   └── src/main/java/{{PACKAGE_BASE}}/thirdparty
    │       ├── client      // Feign 客户端
    │       └── service     // 适配服务实现
    ├── admin-account-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/account
    │       ├── controller  // 控制器
    │       │   └── admin   // B端 Controller (AccountAdminController)
    │       ├── service     // 业务逻辑层
    │       │   ├── AccountService
    │       │   └── AccountServiceImpl
    │       └── model       // 数据模型
    │           ├── dto
    │           └── vo
    ├── frontend-order-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/order
    │       ├── controller
    │       │   └── api     // C端 Controller (OrderApiController) -> /api/order/
    │       ├── service
    │       ├── model
    │       │   ├── dto
    │       │   └── vo
    │       └── enums       // 订单相关枚举
    ├── admin-product-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/product
    │       ├── controller
    │       │   └── admin   // B端 Controller (ProductAdminController) -> /admin/product/
    │       ├── service
    │       ├── model
    │       │   ├── dto
    │       │   └── vo
    │       └── enums
    ├── admin-inventory-module
    │   └── src/main/java/{{PACKAGE_BASE}}/biz/inventory
    │       ├── controller
    │       │   └── admin   // B端 Controller (InventoryAdminController) -> /admin/inventory/
    │       ├── service
    │       └── model
    │           ├── dto
    │           └── vo
    ├── hub-module
    │   └── src/main/java/{{PACKAGE_BASE}}/hub
    │       ├── controller   // 统一回调入口 (HubController -> /hub/{bizType}/{platform}/{tenantId})
    │       ├── adapter      // 平台适配器
    │       │   ├── HubAdapter       // 适配器接口
    │       │   └── HubAdapterFactory // 适配器工厂
    │       ├── model        // 统一回调数据结构
    │       │   ├── HubCallbackData
    │       │   └── HubCallbackEvent
    │       └── event        // 业务事件（转发给业务模块）
    │           ├── PayCallbackEvent
    │           ├── LogisticsCallbackEvent
    │           └── SmsCallbackEvent
    ├── task-module
    │   └── src/main/java/{{PACKAGE_BASE}}/task
    │       ├── order       // 订单相关定时任务
    │       │   ├── OrderTimeoutCloseScheduleTask
    │       │   └── OrderSyncMqConsumer
    │       ├── inventory   // 库存相关任务
    │       │   └── InventorySyncScheduleTask
    │       ├── marketing   // 营销相关任务
    │       │   └── CouponExpireScheduleTask
    │       └── data        // 数据相关任务
    │           └── StatisticsScheduleTask
    └── ...
    ```

- **通用设计**：
  - **核心类骨架 (Skeleton Code)**：
    - **统一响应对象 (`Result<T>`)**：
      ```java
      @Data
      public class Result<T> implements Serializable {
          private String code;
          private String msg;
          private T data;
          
          public static <T> Result<T> success(T data) { ... }
          public static <T> Result<T> error(String code, String msg) { ... }
      }
      ```
    - **数据库基础实体 (`BaseEntity`)**：
      ```java
      @Data
      public abstract class BaseEntity implements Serializable {
          @TableId(type = IdType.AUTO)
          private Long id;
          
          @TableField(fill = FieldFill.INSERT)
          private LocalDateTime createTime;
          
          @TableField(fill = FieldFill.INSERT_UPDATE)
          private LocalDateTime lastModifiedTime;
          
          @TableLogic
          private Integer isDeleted; // 0:未删, 1:已删
      }
      ```
  - **代码模块化设计**：每个模块负责特定的功能，抽象出模块 Service 对外提供方法便于扩展，模块之间解耦。
  - **Lombok 使用**：DTO/VO/Entity 统一使用 `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`。
  - **枚举与常量**：
    - 业务状态值必须定义 Enum，实现 `IEnum<Integer>` 接口（MyBatis-Plus）。
    - 常量类命名为 `XxxConst` (如 `RedisConst`), 字段使用 `public static final`。

  - **错误码规范**：
    - **命名格式**：`{模块码}{类型码}{序号}`，均为数字字符串。
    - **模块码定义**：
      | 模块 | 模块码 | 示例 |
      |------|--------|------|
      | 公共模块 | 00 | 00001 = 系统未知错误 |
      | 用户模块 | 10 | 10001 = 用户不存在, 10002 = 用户已禁用 |
      | 商品模块 | 20 | 20001 = 商品不存在, 20002 = 商品库存不足 |
      | 订单模块 | 30 | 30001 = 订单不存在, 30002 = 订单已取消 |
      | 库存模块 | 40 | 40001 = 库存不足, 40002 = 库存记录不存在 |
      | 支付模块 | 50 | 50001 = 支付失败, 50002 = 支付金额不匹配 |
      | 认证模块 | 60 | 60001 = Token无效, 60002 = Token已过期 |
      | 验证码模块 | 70 | 70001 = 验证码错误, 70002 = 验证码已过期 |
    - **类型码定义**：
      | 类型码范围 | 类型 | 说明 |
      |------------|------|------|
      | 01-09 | 参数校验错误 | 请求参数格式、必填、长度等校验失败 |
      | 10-19 | 数据不存在 | 查询的数据记录不存在 |
      | 20-29 | 状态异常 | 数据状态不满足操作条件（如订单已取消） |
      | 30-39 | 业务规则冲突 | 唯一性约束、业务规则校验失败 |
      | 40-49 | 权限不足 | 用户无权限执行该操作 |
      | 50-59 | 认证失败 | Token无效、登录失效等 |
      | 90-99 | 系统错误 | 内部异常、第三方服务调用失败等 |
    - **错误码示例**：
      ```java
      // ✅ 正确示例 - BizCodeEnum
      public enum BizCodeEnum {
          // 公共错误码 (00)
          UNKNOWN_ERROR("00000", "系统未知错误"),
          PARAM_VALID_ERROR("00001", "参数校验失败"),
          
          // 用户模块 (10)
          USER_NOT_FOUND("10010", "用户不存在"),
          USER_DISABLED("10020", "用户已被禁用"),
          USER_PHONE_EXISTS("10030", "手机号已被注册"),
          
          // 商品模块 (20)
          PRODUCT_NOT_FOUND("20010", "商品不存在"),
          PRODUCT_STOCK_INSUFFICIENT("20020", "商品库存不足"),
          
          // 认证模块 (60)
          TOKEN_INVALID("60010", "Token无效"),
          TOKEN_EXPIRED("60020", "Token已过期"),
          ;
          
          private final String code;
          private final String message;
          
          BizCodeEnum(String code, String message) {
              this.code = code;
              this.message = message;
          }
          
          public String getCode() { return code; }
          public String getMessage() { return message; }
      }
      
      // ✅ 正确示例 - BusinessException
      public class BusinessException extends RuntimeException {
          private String code;
          private String message;
          
          public BusinessException(BizCodeEnum bizCode) {
              this.code = bizCode.getCode();
              this.message = bizCode.getMessage();
          }
          
          public BusinessException(String code, String message) {
              this.code = code;
              this.message = message;
          }
      }
      
      // ❌ 错误示例
      // 直接硬编码错误码数字
      throw new BusinessException(1001, "用户不存在");
      
      // 使用非标准格式的错误码
      throw new BusinessException("USER_NOT_FOUND", "用户不存在");
      ```
    - **错误码使用规范**：
      - 所有业务校验失败**必须**抛出 `BusinessException`，携带标准错误码。
      - 禁止直接硬编码错误码数字，必须通过 `BizCodeEnum` 统一管理。
      - 错误码一旦发布不可变更（保证前端错误码映射表稳定）。

  - **字段命名规范**：
    - **请求/响应字段**：统一使用 **camelCase**（小驼峰）。
      | 正例 | 反例 |
      |------|------|
      | `userName` | `user_name`, `UserName` |
      | `orderId` | `order_id`, `OrderId` |
      | `totalStock` | `total_stock`, `TotalStock` |
    - **数据库字段**：统一使用 **snake_case**（下划线分隔）。
      | 正例 | 反例 |
      |------|------|
      | `user_name` | `userName`, `UserName` |
      | `order_id` | `orderId`, `OrderId` |
      | `total_stock` | `totalStock`, `TotalStock` |
    - **枚举值**：统一使用 **UPPER_SNAKE_CASE**（大写下划线）。
      | 正例 | 反例 |
      |------|------|
      | `ORDER_STATUS_PENDING` | `ORDER_STATUS_PENDING`, `OrderStatusPending` |
      | `USER_TYPE_ADMIN` | `USER_TYPE_ADMIN`, `UserTypeAdmin` |
    - **映射规则**：
      - Entity 字段使用 `@TableField("user_name")` 映射数据库字段。
      - DTO/VO 字段直接使用 camelCase，与前端 JSON 保持一致。
      - 禁止在 DTO/VO 中使用 `@TableField` 注解（不映射数据库）。
    - **强制要求**：
      - API 接口的 JSON 请求/响应必须使用 camelCase。
      - 数据库表字段必须使用 snake_case。
      - 前后端联调时，字段名必须保持一致（camelCase）。

- **命名规范对照表**：
  - **类命名规则**：
    | 类型 | 命名规则 | 正例 | 反例 |
    |------|----------|------|------|
    | Entity | `XxxEntity` | `UserEntity`, `OrderEntity` | `User`, `UserDO` |
    | DTO 请求 | `XxxReq` / `XxxReqDTO` | `UserCreateReq`, `UserLoginReqDTO` | `UserDTO`, `UserInput` |
    | DTO 响应 | `XxxResp` / `XxxVO` | `UserResp`, `UserInfoVO` | `UserDTO`, `UserResult` |
    | Mapper | `XxxMapper` | `UserMapper` | `UserDAO`, `UserRepository` |
    | Mapper XML | `XxxMapper.xml` | `UserMapper.xml` | `UserDAO.xml` |
    | Service 接口 | `XxxService` | `UserService` | `UserBiz`, `UserManager` |
    | Service 实现 | `XxxServiceImpl` | `UserServiceImpl` | `UserService`, `UserBizImpl` |
    | Controller | `XxxController` | `UserController` | `UserAPI`, `UserAction` |
    | 异常类 | `XxxException` | `BusinessException` | `UserError`, `UserException` |
    | 常量类 | `XxxConst` | `RedisConst` | `RedisConstants`, `REDIS_KEY` |
    | 枚举类 | `XxxEnum` | `UserStatusEnum` | `UserStatus`, `UserStatusType` |
    | 事件类 | `XxxEvent` | `OrderCreatedEvent` | `OrderEvent`, `OrderCreateEvent` |
    | 监听类 | `XxxListener` | `OrderCreatedListener` | `OrderEventListener` |
    | 配置类 | `XxxConfig` | `RedisConfig` | `RedisConfiguration` |
  - **方法命名规则**：
    | 类型 | 命名规则 | 正例 | 反例 |
    |------|----------|------|------|
    | 查询单条 | `getXxxByXxx` | `getUserById(Long id)` | `findUser(id)`, `selectUser` |
    | 查询列表 | `listXxx` / `getXxxList` | `listUserByStatus(Integer status)` | `getUsers(status)` |
    | 分页查询 | `pageXxx` | `pageUser(UserQuery query)` | `getUserPage(query)` |
    | 游标分页 | `listXxxByCursor` | `listUserByCursor(UserQuery query, Long lastId, Integer limit)` | - |
    | 新增 | `createXxx` / `saveXxx` | `createUser(UserCreateReq req)` | `addUser(req)`, `insertUser(req)` |
    | 修改 | `updateXxx` | `updateUser(UserUpdateReq req)` | `modifyUser(req)`, `editUser(req)` |
    | 删除 | `deleteXxxByXxx` | `deleteUserById(Long id)` | `removeUser(id)`, `delUser(id)` |
    | 统计 | `countXxx` | `countUserByStatus(Integer status)` | `getUserCount(status)` |
    | 判断是否存在 | `existsXxxByXxx` | `existsUserByPhone(String phone)` | `checkUser(phone)`, `userExists(phone)` |
  - **变量命名规则**：
    - 普通变量：使用小驼峰 `userName`, `orderList`
    - 常量：全大写下划线 `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE`
    - 集合变量：使用复数形式 `userList`, `idList`
    - 布尔变量：以 `is`, `has`, `can` 开头 `isDeleted`, `hasPermission`, `canAccess`
    - 临时变量：使用泛化名称 `obj`, `entity`, `req`, `resp`
  
  - **包名命名规则**：
    | 包名 | 用途 | 示例 |
    |------|------|------|
    | `entity` | 数据库实体 | `com.example.dal.entity` |
    | `mapper` | MyBatis 接口 | `com.example.dal.mapper` |
    | `service` | 服务接口 | `com.example.biz.service` |
    | `service.impl` | 服务实现 | `com.example.biz.service.impl` |
    | `controller` | 控制器 | `com.example.biz.controller` |
    | `dto` | 请求/响应对象 | `com.example.biz.model.dto` |
    | `vo` | 视图对象 | `com.example.biz.model.vo` |
    | `enums` | 枚举类 | `com.example.common.enums` |
    | `constants` | 常量类 | `com.example.common.constants` |
    | `exception` | 异常类 | `com.example.common.exception` |
    | `config` | 配置类 | `com.example.common.config` |
    | `utils` | 工具类 | `com.example.common.utils` |
    | `client` | Feign 客户端 | `com.example.thirdparty.client` |
    | `listener` | 事件监听器 | `com.example.biz.listener` |
    | `event` | 事件类 | `com.example.biz.event` |

- **Redis Key 命名规范**：
  - **命名格式**：`{业务前缀}:{模块名}:{具体标识}`
  - **示例**：
    | 用途 | 命名规则 | 正例 |
    |------|----------|------|
    | 用户信息缓存 | `user:info:{userId}` | `user:info:1001` |
    | 用户Token | `user:token:{userId}` | `user:token:1001` |
    | 验证码 | `verify:code:{phone}` | `verify:code:13800138000` |
    | 分布式锁 | `lock:{biz}:{id}` | `lock:order:pay:1001` |
    | 幂等Key | `idempotent:{biz}:{uniqueKey}` | `idempotent:order:create:abc123` |
    | 分布式锁 | `{prefix}:lock:{biz}:{id}` | `app:lock:order:pay:1001` |
  - **强制要求**：
    - 所有 Key 必须定义在常量类中，禁止硬编码
    - 必须设置合理的过期时间
    - 禁止使用模糊匹配批量删除（使用 `SCAN` 命令替代）

- **日志规范**：
  - **工具选择**：必须使用 SLF4J 接口配合 Logback 实现。禁止使用 `System.out` 或 `e.printStackTrace()`。
  - **注解使用**：类上统一使用 Lombok 的 `@Slf4j` 注解。
  - **日志打印场景与格式**：
    - **Service 方法入口**：
      - 必须打印。
      - 格式：`log.info("Method started: class={}, method={}, params={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(params));`
    - **Service 方法出口**：
      - 建议打印（关键业务必须打印）。
      - 格式：`log.info("Method finished: class={}, method={}, result={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(result));`
    - **异常捕获**：
      - 必须打印堆栈信息。
      - 格式：`log.error("Method failed: class={}, method={}, params={}, error={}", getClass().getSimpleName(), "methodName", JSON.toJSONString(params), e.getMessage(), e);`
    - **逻辑分支**：
      - 关键的 if/else 或 switch 分支必须打印日志记录决策路径。
  - **敏感信息脱敏**：
    - 在打印日志（尤其是 JSON 序列化）时，必须对手机号、身份证、密码等敏感字段进行脱敏处理（建议使用 Fastjson Filter 或 Logback Masking）。


- **事务与并发控制规范**：
  - **事务管理**：
    - **注解使用**：必须使用 `@Transactional(rollbackFor = Exception.class)`，禁止使用默认配置（仅回滚 RuntimeException）。
    - **范围控制**：仅在 Service 层方法上添加事务，禁止在 Controller 层或耗时操作（如 RPC、文件 IO）上加事务。
    - **失效场景**：注意自调用失效问题，必须通过 `AopContext.currentProxy()` 调用或注入自身 Bean。
  - **并发控制**：
    - **分布式锁**：使用 Redisson 实现。
    - **锁粒度**：Key 必须包含业务唯一标识（如 `lock:order:pay:{orderId}`）。
    - **使用模式**：必须使用 try-finally 块释放锁。
      ```java
      RLock lock = redissonClient.getLock("key");
      if (lock.tryLock()) {
          try {
              // 业务逻辑
          } finally {
              lock.unlock();
          }
      }
      ```
  - **并发控制判断标准**（AI 生成代码专用）：
    - **判断流程**：
      1. **是否是写操作？** → 否：无需并发控制
      2. **是否涉及资金/库存扣减？** → 是：必须使用分布式锁
      3. **是否涉及多表事务？** → 是：使用数据库行锁（`@Version` 或 `SELECT FOR UPDATE`）
      4. **是否存在竞态条件？** → 是：使用 Redis 分布式锁
    - **锁选择策略**：
      | 场景 | 锁类型 | 示例 |
      |------|--------|------|
      | 库存扣减、余额扣减 | 分布式锁 (Redisson) | `lock:stock:reduce:{skuId}` |
      | 订单创建（防重复提交） | 分布式锁 | `lock:order:create:{userId}` |
      | 多表数据一致性 | 数据库行锁 | `@Version` 乐观锁 |
      | 单表状态更新 | 无需额外锁 | 依赖数据库事务 |
    - **代码示例**：
      ```java
      // ✅ 正确示例 - 库存扣减使用分布式锁
      @Override
      @Transactional(rollbackFor = Exception.class)
      public boolean reduceStock(Long skuId, Integer quantity) {
          String lockKey = "lock:stock:reduce:" + skuId;
          RLock lock = redissonClient.getLock(lockKey);
          
          if (!lock.tryLock()) {
              throw new BusinessException(BizCodeEnum.STOCK_BUSY);
          }
          
          try {
              // 库存扣减逻辑
              StockEntity stock = stockMapper.selectOne(
                  new LambdaQueryWrapper<StockEntity>()
                      .eq(StockEntity::getSkuId, skuId)
                      .gt(StockEntity::getStock, quantity)
              );
              if (stock == null) {
                  throw new BusinessException(BizCodeEnum.PRODUCT_STOCK_INSUFFICIENT);
              }
              stock.setStock(stock.getStock() - quantity);
              stockMapper.updateById(stock);
          } finally {
              lock.unlock();
          }
          return true;
      }
      
      // ❌ 错误示例 - 库存扣减不使用锁
      public boolean reduceStock(Long skuId, Integer quantity) {
          StockEntity stock = stockMapper.selectById(skuId);
          stock.setStock(stock.getStock() - quantity);  // 并发问题
          stockMapper.updateById(stock);
      }
      ```
  - **幂等性判断标准**（AI 生成代码专用）：
    - **必须幂等的场景**：
      - 支付/扣款类操作（重复支付会导致资损）
      - 下单类操作（重复下单会导致库存超卖）
      - 库存扣减类操作（重复扣减会导致负库存）
      - 状态流转类操作（重复流转会导致状态异常）
    - **建议幂等的场景**：
      - 加购操作（重复加购无大碍，但建议幂等）
      - 收藏/点赞操作（重复操作无意义）
      - 信息变更操作（重复提交同数据）
    - **无需幂等的场景**：
      - 纯查询接口（GET）
      - 只读操作（如列表查询、详情查询）
    - **幂等性实现方案**：
      | 方案 | 适用场景 | 实现方式 |
      |------|----------|----------|
      | 唯一键 + INSERT IGNORE | 插入操作 | 使用业务唯一键作为 Redis Key |
      | 状态机 + 条件更新 | 状态流转 | `UPDATE ... WHERE status=PENDING AND id=?` |
      | 分布式锁 | 并发防重 | 获取锁后执行，同一请求只能进入一次 |
      | Token 机制 | 表单提交 | 前端提交 Token，后端验证后删除 |
    - **Redis 幂等 Key 规范**：
      - 格式：`idempotent:{业务}:{唯一标识}`
      - 示例：
        - `idempotent:order:create:{userId}:{skuId}` - 防止重复下单
        - `idempotent:payment:pay:{orderId}` - 防止重复支付
        - `idempotent:stock:reduce:{skuId}` - 防止重复扣减
      - 过期时间：建议 24 小时（根据业务调整）
    - **代码示例**：
      ```java
      // ✅ 正确示例 - 使用 Redis 实现订单创建幂等
      @Override
      @Transactional(rollbackFor = Exception.class)
      public Long createOrder(OrderCreateReq req) {
          String idempotentKey = "idempotent:order:create:" + req.getUserId() + ":" + req.getSkuId();
          Boolean acquired = redisTemplate.opsForValue().setIfAbsent(
              idempotentKey, "1", 24, TimeUnit.HOURS);
          
          if (Boolean.FALSE.equals(acquired)) {
              throw new BusinessException(BizCodeEnum.ORDER_DUPLICATE_SUBMIT);
          }
          
          try {
              // 订单创建逻辑
              // 1. 校验库存
              // 2. 创建订单
              // 3. 扣减库存
          } catch (Exception e) {
              redisTemplate.delete(idempotentKey);  // 失败时删除 Key，允许重试
              throw e;
          }
          return orderId;
      }
      
      // ✅ 正确示例 - 使用状态机实现订单取消幂等
      @Override
      @Transactional(rollbackFor = Exception.class)
      public void cancelOrder(Long orderId) {
          // 使用条件更新实现幂等
          int rows = orderMapper.updateStatusByIdAndStatus(
              orderId, 
              OrderStatusEnum.PENDING.getValue(),  // 前置状态
              OrderStatusEnum.CANCELLED.getValue()  // 目标状态
          );
          
          if (rows == 0) {
              // 找不到待取消的订单，说明订单已被取消或状态异常
              throw new BusinessException(BizCodeEnum.ORDER_STATUS_ERROR);
          }
      }
      
      // ❌ 错误示例 - 不做幂等控制
      @Override
      public void cancelOrder(Long orderId) {
          OrderEntity order = orderMapper.selectById(orderId);
          if (order.getStatus().equals(OrderStatusEnum.PENDING)) {
              order.setStatus(OrderStatusEnum.CANCELLED);  // 并发时可能重复取消
              orderMapper.updateById(order);
          }
      }
      ```

- **注释规范**：
  - Service 接口及实现类方法必须添加 Javadoc 注释，包含 `@param`, `@return`, `@throws`。
  - Controller 方法必须添加 Javadoc 注释，说明接口用途。
  - Mapper 方法必须添加 Javadoc 注释。

- **代码示例（正确 vs 错误）**：
  - **Service 接口**：
    ```java
    // ✅ 正确示例
    public interface UserService {
        /**
         * 根据ID查询用户
         *
         * @param id 用户ID
         * @return 用户信息
         * @throws BusinessException 用户不存在
         */
        UserResp getById(Long id) throws BusinessException;
        
        /**
         * 创建用户
         *
         * @param req 创建请求
         * @return 用户ID
         */
        Long createUser(UserCreateReq req);
    }
    
    // ❌ 错误示例
    public interface UserService {  // 缺少注释
        User getById(Long id);  // 返回类型不明确，缺少注释
        
        Long addUser(User user);  // 方法命名不符合规范
    }
    ```
  - **Service 实现类**：
    ```java
    // ✅ 正确示例
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class UserServiceImpl implements UserService {
        private final UserDalService userDalService;
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public Long createUser(UserCreateReq req) {
            log.info("Method started: class={}, method={}, params={}", 
                "UserServiceImpl", "createUser", JSON.toJSONString(req));
            
            // 参数校验
            if (req == null || StringUtils.isBlank(req.getPhone())) {
                throw new BusinessException(400, "手机号不能为空");
            }
            
            // 业务逻辑
            UserEntity entity = UserEntity.builder()
                .phone(req.getPhone())
                .build();
            userDalService.save(entity);
            
            log.info("Method finished: class={}, method={}, result={}", 
                "UserServiceImpl", "createUser", entity.getId());
            return entity.getId();
        }
    }
    
    // ❌ 错误示例
    @Service
    public class UserServiceImpl implements UserService {  // 缺少 @Slf4j
        @Autowired
        private UserDalService userDalService;  // 缺少 @RequiredArgsConstructor
        
        @Override
        public Long createUser(UserCreateReq req) {  // 缺少 @Transactional(rollbackFor = Exception.class)
            // 缺少日志
            if (req == null) {
                return null;  // 禁止返回 null
            }
            userDalService.save(req);
            return 1L;  // 应该是新增实体的ID
        }
    }
    ```
  - **Controller**：
    ```java
    // ✅ 正确示例
    @Tag(name = "用户管理")
    @RestController
    @RequestMapping("/api/user")
    @RequiredArgsConstructor
    public class UserController {
        private final UserService userService;
        
        @Operation(summary = "根据ID获取用户")
        @GetMapping("/{id}")
        public Result<UserResp> getById(@Parameter(description = "用户ID") @PathVariable Long id) {
            UserResp resp = userService.getById(id);
            return Result.success(resp);
        }
    }
    
    // ❌ 错误示例
    @RestController
    @RequestMapping("/api/user")
    public class UserController {  // 缺少 @Tag 注解
        @Autowired
        private UserService userService;
        
        @GetMapping("/{id}")
        public Result getById(Long id) {  // 缺少 @Operation 和 @Parameter 注解，泛型类型不明确
            return Result.success(userService.getById(id));
        }
    }
    ```
  - **Entity**：
    ```java
    // ✅ 正确示例
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @TableName("t_user")
    public class UserEntity extends BaseEntity {
        @TableField("user_name")
        private String userName;
        
        @TableField("phone")
        private String phone;
        
        @TableLogic
        @TableField("is_deleted")
        private Integer isDeleted;
    }
    
    // ❌ 错误示例
    @Data
    @TableName("t_user")
    public class UserEntity extends BaseEntity {  // 缺少 @Builder, @NoArgsConstructor, @AllArgsConstructor
        private Long id;  // 主键应在 BaseEntity 中定义
        private String userName;  // 缺少 @TableField
        private Integer isDeleted;  // 缺少 @TableLogic
    }
    ```
  - **枚举类**：
    ```java
    // ✅ 正确示例
    @Getter
    public enum UserStatusEnum implements IEnum<Integer> {
        DISABLED(0, "禁用"),
        ENABLED(1, "启用");
        
        private final Integer value;
        private final String desc;
        
        UserStatusEnum(Integer value, String desc) {
            this.value = value;
            this.desc = desc;
        }
    }
    
    // ❌ 错误示例
    public enum UserStatus {  // 缺少 Enum 后缀
        DISABLED(0),  // 缺少描述
        ENABLED(1);
        
        private final int value;
    }
    ```
  - **异常处理**：
    ```java
    // ✅ 正确示例 - Service 层抛出异常
    @Override
    public UserResp getById(Long id) {
        UserEntity entity = userDalService.getById(id);
        if (entity == null) {
            throw new BusinessException(404, "用户不存在");
        }
        return convertToResp(entity);
    }
    
    // ❌ 错误示例 - Service 层返回 null 或错误码
    @Override
    public UserResp getById(Long id) {
        UserEntity entity = userDalService.getById(id);
        if (entity == null) {
            return null;  // 禁止返回 null
        }
        return convertToResp(entity);
    }
    // 或者
    @Override
    public UserResp getById(Long id) {
        // ...
        return Result.error(404, "用户不存在");  // Service 层禁止直接返回 Result
    }
    ```

- **参数校验规范**：
  - **校验层级**：
    | 层级 | 校验方式 | 适用场景 | 错误码 |
    |------|----------|----------|--------|
    | Controller 层 | `@Valid` + JSR-303 注解 | 简单格式校验（非空、长度、正则） | 00001 |
    | Service 层 | 手动校验 + `BusinessException` | 业务逻辑校验（唯一性、状态判断） | 对应模块错误码 |
    - **强制要求**：禁止在 Mapper 层进行校验
  - **校验规则结构化规范**（AI 生成代码专用）：
    - API 接口文档中必须使用以下结构化格式定义校验规则：
      ```markdown
      | 字段名 | 规则类型 | 具体约束 | 错误码 | 错误提示 |
      |--------|----------|----------|--------|----------|
      | skuName | 非空 | - | 400001 | 商品名称不能为空 |
      | email | 格式 | 正则：^[\w-]+@[\w]+\.[\w]+$ | 400002 | 邮箱格式不正确 |
      | price | 数值 | > 0, 最多2位小数 | 400003 | 价格必须大于0 |
      | skuCode | 唯一性 | 查询 sku 表 | 400004 | 商品编码已存在 |
      | orderId | 存在性 | 查询 order 表，状态=PENDING | 30020 | 订单状态不可取消 |
      ```
    - **规则类型定义**：
      | 规则类型 | 说明 | JSR-303 注解 | 校验位置 |
      |----------|------|--------------|----------|
      | 非空 | 字段不能为 null 或空字符串 | `@NotNull`, `@NotBlank` | Controller |
      | 长度 | 字符串长度范围 | `@Size(min=?, max=?)` | Controller |
      | 格式 | 正则匹配 | `@Pattern(regexp="...")` | Controller |
      | 数值 | 数值范围 | `@Min`, `@Max`, `@DecimalMin` | Controller |
      | 邮箱 | 邮箱格式 | `@Email` | Controller |
      | 手机号 | 手机号格式 | `@Pattern` | Controller |
      | 枚举值 | 必须是指定枚举值之一 | `@EnumValue` (自动转换) | Controller |
      | 唯一性 | 数据库唯一约束校验 | - | Service |
      | 存在性 | 数据库记录存在性校验 | - | Service |
      | 状态约束 | 数据状态满足操作条件 | - | Service |
      | 关联校验 | 关联数据有效性校验 | - | Service |
  - **常用校验注解**：
    | 注解 | 作用 | 示例 |
    |------|------|------|
    | `@NotNull` | 不能为 null | `@NotNull(message = "ID不能为空")` |
    | `@NotBlank` | 不能为空字符串 | `@NotBlank(message = "用户名不能为空")` |
    | `@Size` | 长度范围 | `@Size(min = 6, max = 20, message = "密码长度6-20位")` |
    | `@Pattern` | 正则校验 | `@Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式错误")` |
    | `@Min`/`@Max` | 数值范围 | `@Min(value = 1, message = "页码最小为1")` |
    | `@Email` | 邮箱格式 | `@Email(message = "邮箱格式错误")` |
    | `@DecimalMin`/`@DecimalMax` | BigDecimal 范围 | `@DecimalMin(value = "0.01", message = "价格必须大于0")` |
  - **代码示例**：
    ```java
    // ✅ 正确示例 - Controller 层使用 @Valid
    @PostMapping
    public Result<Long> create(@RequestBody @Valid UserCreateReq req) {
        Long id = userService.createUser(req);
        return Result.success(id);
    }
    
    // DTO 中定义校验规则
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class UserCreateReq {
        @NotBlank(message = "手机号不能为空")
        @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式错误")
        private String phone;
        
        @NotBlank(message = "密码不能为空")
        @Size(min = 6, max = 20, message = "密码长度6-20位")
        private String password;
        
        @Email(message = "邮箱格式错误")
        private String email;
    }
    
    // ✅ 正确示例 - Service 层手动校验
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Long createUser(UserCreateReq req) {
        // 业务逻辑校验
        if (userDalService.existsByPhone(req.getPhone())) {
            throw new BusinessException(BizCodeEnum.USER_PHONE_EXISTS);
        }
        
        UserEntity entity = UserEntity.builder()
            .phone(req.getPhone())
            .build();
        userDalService.save(entity);
        return entity.getId();
    }
    
    // ❌ 错误示例
    @PostMapping
    public Result<Long> create(@RequestBody UserCreateReq req) {  // 缺少 @Valid
        // 缺少校验
        Long id = userService.createUser(req);
        return Result.success(id);
    }
    
    // ❌ 错误示例 - Service 层直接返回 null
    @Override
    public UserResp getById(Long id) {
        UserEntity entity = userDalService.getById(id);
        if (entity == null) {
            return null;  // 禁止返回 null，必须抛出异常
        }
        return convertToResp(entity);
    }
    ```

- **数据持久层 (Mapper)**：
  - 继承 MyBatis-Plus 的 `BaseMapper<T>` 接口。
  - 涉及到分页查询时，必须使用ID作为排序分页查询的依据, 确保分页查询的结果是连续的。
  - 必须提供的自定义 CRUD 方法 (如果 BaseMapper 不满足): 
    - `insertBatch(List<T> list)`
    - `selectByCondition(T query)`
    - `selectOrderByIdPage(T query, Long lastId, Integer limit)`
    - `selectOrderByIdList(T query, Long lastId, Integer limit)`
    - `updateById(T entity)`
    - `deleteById(Long id)`

- **异常处理规范**：
  - **自定义异常**：
    - 创建 `BusinessException` 继承 `RuntimeException`。
    - 必须包含字段：`Integer code` (错误码), `String message` (错误信息)。
  - **全局异常处理 (GlobalExceptionHandler)**：
    - 使用 `@RestControllerAdvice` 注解。
    - **处理逻辑**：
      - 捕获 `BusinessException` -> 返回 `Result.error(e.getCode(), e.getMessage())`。
      - 捕获 `MethodArgumentNotValidException` (参数校验失败) -> 返回 `Result.error(400, "参数校验失败: " + fieldError.getDefaultMessage())`。
      - 捕获 `Exception` (兜底) -> 打印 Error 日志 -> 返回 `Result.error(500, "系统繁忙，请稍后重试")`。
  - **抛出原则**：
    - 业务层 (Service) 遇到逻辑错误（如库存不足、用户不存在），**必须**抛出 `BusinessException`，禁止直接返回 null 或错误码对象。
    - 禁止在 Controller 层捕获异常（除非为了特殊降级处理），应统一由全局异常处理器接管。

- **第三方服务集成**：
  - 独立模块 (如 `third-party-sms`)。
  - 定义统一接口 (如 `SmsService`) 继承 IApiService，实现类与接口同名，后缀为 `Impl`，如 `SmsServiceImpl`中封装具体逻辑, IApiService 代码如下：
    ```java
    public interface IApiService {
    /**
     * 请求 指定业务 服务器
     *
     * @param request 请求
     * @param <Resp>  响应
     */
    <Resp extends ApiResponse> Resp request(ApiRequest<Resp> request) throws ApiException;
    /**
     * 请求 指定业务 服务器
     *
     * @param trackId 追踪ID
     * @param request 请求
     * @param <Resp>  响应
     */
    <Resp extends ApiResponse> Resp request(String trackId, ApiRequest<Resp> request) throws ApiException;
    }
    ```
    ```java
    public interface ApiRequest<resp extends ApiResponse> extends Serializable {
    /**
     * 请求的路径
     */
    String requestMappingUrl();
    /**
     * 是否对请求body进行加密处理
     */
    default boolean ciphertextEnable() {
        return false;
    }
    /**
     * 请求的响应结构体
     */
    Class<resp> respClass();
    /**
     * 请求所带的token
     */
    default String accessToken(){
        return null;
    }
    }
    ```
    ```java
    public interface ApiResponse extends Serializable {
    }
    ```
  - 定义统一HTTP调用方式使用 **Feign Client**，实现类添加 `@FeignClient` 注解。
  - 定义统一HTTP调用方法：
    ```java
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    String postByURI(URI uri, @RequestHeader("trackId") String trackId, @RequestBody Object body);
    ```
  - **Feign 日志规范 (CURL)**：
    - **强制要求**：所有 Feign 客户端必须配置自定义 `Logger` 实现类 FeignLogger，将请求日志格式化为 `curl` 命令。
    - **日志级别**：Feign Client 配置必须设为 `Logger.Level.FULL`。
    - **请求日志 (`logRequest`)**：
       - 必须包含：Method, URL, Headers, Body。
       - 格式要求：使用多行 `curl` 命令格式，每行一个参数，使用 `\` 换行，确保可读性和直接复制执行。
       - 示例：
         ```bash
         curl -X POST 'https://api.example.com/v1/users' \
           -H 'Content-Type: application/json' \
           -H 'Authorization: Bearer xxxxx' \
           -d '{
             "name": "test",
             "age": 18
           }'
         ```
     - **响应日志 (`logAndRebufferResponse`)**：
      - 必须包含：HTTP Status, 耗时 (Latency), Response Body。
      - 示例：`FEIGN_RESP -> curl -X POST 'http://10.0.0.1/api/sms' [status:200] (120ms) body: {"code":200,"msg":"success"}`
    - **异常日志**：
      - 当 Feign 调用抛出异常时，必须在 ERROR 级别日志中打印原始请求的 CURL 命令。

- **异步处理与事件驱动规范**：
  - **核心原则**：
    - 接口响应时间超过 500ms 的核心提交操作，必须采用异步处理。
    - 核心业务流程中的副作用（Side Effects，如发通知、统计）必须通过事件解耦。
  - **技术实现**：
    - **实现方式**：使用 Spring Event (`ApplicationEventPublisher`) 配合 `@EventListener` 和 `ThreadPoolTaskExecutor` 实现进程内解耦。
    - **发布事件**：
      ```java
      @Autowired
      private ApplicationEventPublisher eventPublisher;
      @Autowired
      private ThreadPoolTaskExecutor taskExecutor;

      public void publishEvent(DelayHandleTaskEvent event, boolean isAsync) {
        if (isAsync) {
            taskExecutor.execute(() -> eventPublisher.publishEvent(event));
        } else {
            eventPublisher.publishEvent(event);
        }
      }
      ```
    - **监听事件**：
      ```java
      @Component
      public class DelayHandleTaskListener {
          @EventListener
          public void handleDelayHandleTaskEvent(DelayHandleTaskEvent event) {
              // 异步处理逻辑
          }
      }
      ```
    - **强制要求**：
      - 必须配置自定义线程池 (TaskExecutor)，禁止使用 Spring 默认的 SimpleAsyncTaskExecutor。
      - 事件类名必须以 `Event` 结尾 (如 `OrderCreatedEvent`)。
    - **分布式异步**：在跨服务解耦时使用 MQ/Redis。
  - **API 交互模式**：
    - **提交接口**：
      - 收到请求后，生成 `taskId`，存入 Redis/DB 初始化状态为 `PENDING`。
      - 通过 `eventPublisher.publishEvent(...)` 触发异步处理。
      - 立即返回响应：`{ "code": 200, "data": { "taskId": "t_1001", "status": "PENDING" } }`。
    - **结果轮询接口**：
      - 前端轮询 `GET /api/async-tasks/{taskId}` (建议间隔 1s/3s/5s 退避)。
      - 响应结构：
        ```json
        {
          "code": 200,
          "data": {
            "taskId": "t_1001",
            "status": "SUCCESS", // PENDING, PROCESSING, SUCCESS, FAILED
            "progress": 100,     // 可选：进度百分比
            "result": { ... },   // 成功时的业务数据
            "errorMsg": null     // 失败时的错误信息
          }
        }
        ```
  - **异常与兜底**：
    - 异步方法内部**必须** try-catch 所有异常。
    - 捕获异常后：1. 打印 ERROR 日志；2. 将任务状态更新为 `FAILED`；3. 记录错误信息。

- **前端代码规范**：
  - **目录结构**：
    - `src/views`: 页面视图组件
    - `src/components`: 全局通用组件
    - `src/hooks`: 组合式 API (Composables)
    - `src/store`: 状态管理 (推荐 Pinia)
    - `src/api`: 后端接口封装
  - **命名规范**：
    - 组件文件：使用大驼峰命名 (PascalCase)，如 `UserProfile.vue`。
    - 目录命名：使用小写短横线 (kebab-case)，如 `user-profile`。
  - **网络请求**：
    - 统一封装 Axios，拦截器中处理 `Result<T>` 响应结构。
    - API 模块与后端 Controller 对应，方法名保持语义一致。

- **数据库设计规范**：
  - **命名规范**：
    - 表名：使用 `t_` 前缀，如 `t_user`。
    - 字段名：使用下划线分隔 (snake_case)，如 `user_name`。
    - **索引命名**：
      - 普通索引：`idx_{字段名}` (如 `idx_user_name`)
      - 唯一索引：`uk_{字段名}` (如 `uk_phone`)
      - 组合索引：`idx_{字段1}_{字段2}`
  - **基础约束**：
    - **字符集**：统一使用 `utf8mb4`，排序规则 `utf8mb4_general_ci`。
    - **外键**：禁止使用物理外键，关联关系在业务代码中维护。
    - **存储引擎**：必须使用 InnoDB。
  - **通用字段**：每张表必须包含：
    - `id` (主键, BigInt, 自增/雪花算法)
    - `create_time` (创建时间, timestamp, default CURRENT_TIMESTAMP)
    - `last_modified_time` (更新时间, timestamp, default CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)
    - `status` (状态值, TinyInt, 1:正常, 0:禁用)
    - `is_deleted` (逻辑删除, TinyInt, 0:未删, 1:已删)
  - **数据类型**：
    - 金额：使用 `Decimal(10, 4)`。
    - 布尔值：使用 `TinyInt` (0/1)。
    - 枚举值：使用 `TinyInt` 或 `Int`。

- **Git 提交与版本管理**：
  - **Commit Message**：采用 Conventional Commits 规范。
    - `feat`: 新功能
    - `fix`: 修复 Bug
    - `docs`: 文档变更
    - `style`: 代码格式调整 (不影响逻辑)
    - `refactor`: 代码重构
    - `chore`: 构建/工具链变动
  - **分支管理**：
    - `main/master`: 主分支，随时可发布。
    - `develop`: 开发分支。
    - `feature/*`: 功能分支，从 main/master 新建，完成后合并到 develop。

- **配置文件规范**：
  - **命名规范**：
    - 配置文件：`application-{env}.yml`
    - 配置项：使用 kebab-case (如 `custom-thread-pool.core-size`)。
  - **配置结构**：
    ```yaml
    server:
      port: 8080
    spring:
      application:
        name: {{SERVICE_NAME}}
      datasource: ...
      redis: ...
    # 自定义配置
    app:
      sms:
        enabled: true
      thread-pool:
        core-size: 10
    ```
  - **多环境配置**：
    - `application.yml`: 公共配置
    - `application-sit.yml`: 测试环境
    - `application-prod.yml`: 生产环境
  - **敏感信息**：
    - 生产环境密码、密钥禁止明文提交到代码库，应通过环境变量或 CI/CD 注入。

- **测试规范**：
  - **技术选型**：JUnit 5 + Spring Boot Test + H2/Mockito。
  - **单元/集成测试**：
    - **注解使用**：
      - 使用 `@SpringBootTest` 启动完整上下文（适用于验证 Service与 DB/Cache 的集成逻辑）。
      - 配合 `@Transactional` 确保测试数据回滚，不污染数据库。
    - **Mock 策略**：
      - 外部服务（如 Feign Client）必须使用 `@MockBean` 进行模拟，隔离外部依赖。
    - **代码示例**：
      ```java
      @SpringBootTest
      @Transactional // 自动回滚事务
      @Slf4j
      class UserServiceTest {
          @Autowired
          private UserService userService;
          
          @MockBean // Mock 外部短信服务
          private SmsService smsService;

          @Test
          void should_create_user_success() {
              // Arrange
              UserCreateReq req = new UserCreateReq("test_user");
              when(smsService.sendCode(anyString())).thenReturn(true);
              
              // Act
              Long userId = userService.createUser(req);
              
              // Assert
              assertThat(userId).isNotNull();
              // 验证 DB 是否写入 (Integration Test 优势)
              UserVO user = userService.getUserById(userId);
              assertThat(user.getUsername()).isEqualTo("test_user");
          }
      }
      ```
  - **测试覆盖率**：核心业务模块行覆盖率建议 > 60%。

- **代码模板（快速生成）**：
  - **Entity 模板**：
    ```java
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @TableName("t_{table_name}")
    public class {ClassName}Entity extends BaseEntity {
        @TableField("{field_name}")
        private {FieldType} {fieldName};
    }
    ```
  - **DTO 请求模板**：
    ```java
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class {ClassName}Req {
        @NotBlank(message = "xxx不能为空")
        private String xxx;
    }
    ```
  - **VO 响应模板**：
    ```java
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class {ClassName}Resp {
        private Long id;
        private String xxx;
    }
    ```
  - **Mapper 模板**：
    ```java
    @Mapper
    public interface {ClassName}Mapper extends BaseMapper<{ClassName}Entity> {
        /**
         * 根据条件查询列表
         *
         * @param query 查询条件
         * @return 实体列表
         */
        List<{ClassName}Entity> selectByCondition(@Param("query") {ClassName}Query query);
        
        /**
         * 游标分页查询
         *
         * @param query 查询条件
         * @param lastId 游标ID
         * @param limit 每页大小
         * @return 实体列表
         */
        List<{ClassName}Entity> selectOrderByIdPage(@Param("query") {ClassName}Query query,
                                                     @Param("lastId") Long lastId,
                                                     @Param("limit") Integer limit);
    }
    ```
  - **DAL Service 接口模板**：
    ```java
    public interface {ClassName}DalService {
        /**
         * 新增
         *
         * @param entity 实体
         * @return 是否成功
         */
        boolean save({ClassName}Entity entity);
        
        /**
         * 根据ID查询
         *
         * @param id 主键ID
         * @return 实体
         */
        {ClassName}Entity getById(Long id);
        
        /**
         * 修改
         *
         * @param entity 实体
         * @return 是否成功
         */
        boolean updateById({ClassName}Entity entity);
        
        /**
         * 根据ID删除
         *
         * @param id 主键ID
         * @return 是否成功
         */
        boolean deleteById(Long id);
        
        /**
         * 根据条件查询列表
         *
         * @param query 查询条件
         * @return 实体列表
         */
        List<{ClassName}Entity> listByCondition({ClassName}Query query);
    }
    ```
  - **DAL Service 实现模板**：
    ```java
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class {ClassName}DalServiceImpl implements {ClassName}DalService {
        private final {ClassName}Mapper {className}Mapper;
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public boolean save({ClassName}Entity entity) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}DalServiceImpl", "save", JSON.toJSONString(entity));
            boolean result = {className}Mapper.insert(entity) > 0;
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}DalServiceImpl", "save", result);
            return result;
        }
        
        @Override
        public {ClassName}Entity getById(Long id) {
            return {className}Mapper.selectById(id);
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public boolean updateById({ClassName}Entity entity) {
            return {className}Mapper.updateById(entity) > 0;
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public boolean deleteById(Long id) {
            return {className}Mapper.deleteById(id) > 0;
        }
        
        @Override
        public List<{ClassName}Entity> listByCondition({ClassName}Query query) {
            return {className}Mapper.selectByCondition(query);
        }
    }
    ```
  - **Service 接口模板**：
    ```java
    public interface {ClassName}Service {
        /**
         * 根据ID查询
         *
         * @param id 主键ID
         * @return 响应对象
         * @throws BusinessException 实体不存在
         */
        {ClassName}Resp getById(Long id) throws BusinessException;
        
        /**
         * 创建
         *
         * @param req 请求对象
         * @return 主键ID
         */
        Long create({ClassName}Req req);
        
        /**
         * 修改
         *
         * @param req 请求对象
         */
        void update({ClassName}Req req);
        
        /**
         * 根据ID删除
         *
         * @param id 主键ID
         */
        void deleteById(Long id);
        
        /**
         * 分页查询
         *
         * @param query 查询条件
         * @return 分页结果
         */
        PageResult<{ClassName}Resp> page({ClassName}Query query);
    }
    ```
  - **Service 实现模板**：
    ```java
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class {ClassName}ServiceImpl implements {ClassName}Service {
        private final {ClassName}DalService {className}DalService;
        private final {ClassName}Mapper {className}Mapper;
        
        @Override
        public {ClassName}Resp getById(Long id) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "getById", id);
            {ClassName}Entity entity = {className}DalService.getById(id);
            if (entity == null) {
                throw new BusinessException(404, "{ClassName}不存在");
            }
            {ClassName}Resp resp = convertToResp(entity);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "getById", resp.getId());
            return resp;
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public Long create({ClassName}Req req) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "create", JSON.toJSONString(req));
            // 参数校验
            this.validate(req);
            // 业务逻辑
            {ClassName}Entity entity = convertToEntity(req);
            {className}DalService.save(entity);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "create", entity.getId());
            return entity.getId();
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public void update({ClassName}Req req) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "update", JSON.toJSONString(req));
            // 参数校验
            this.validate(req);
            {ClassName}Entity entity = {className}DalService.getById(req.getId());
            if (entity == null) {
                throw new BusinessException(404, "{ClassName}不存在");
            }
            // 更新逻辑
            this.updateEntity(entity, req);
            {className}DalService.updateById(entity);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "update", req.getId());
        }
        
        @Override
        @Transactional(rollbackFor = Exception.class)
        public void deleteById(Long id) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "deleteById", id);
            {ClassName}Entity entity = {className}DalService.getById(id);
            if (entity == null) {
                throw new BusinessException(404, "{ClassName}不存在");
            }
            {className}DalService.deleteById(id);
            log.info("Method finished: class={}, method={}, result={}",
                "{ClassName}ServiceImpl", "deleteById", id);
        }
        
        @Override
        public PageResult<{ClassName}Resp> page({ClassName}Query query) {
            log.info("Method started: class={}, method={}, params={}",
                "{ClassName}ServiceImpl", "page", JSON.toJSONString(query));
            // 分页查询
            List<{ClassName}Entity> list = {className}Mapper.selectOrderByIdPage(
                query, query.getLastId(), query.getPageSize());
            long total = {className}Mapper.selectCount(query);
            List<{ClassName}Resp> respList = list.stream()
                .map(this::convertToResp)
                .collect(Collectors.toList());
            log.info("Method finished: class={}, method={}, result={{}, {}}}",
                "{ClassName}ServiceImpl", "page", total, respList.size());
            return PageResult.<{ClassName}Resp>builder()
                .total(total)
                .list(respList)
                .build();
        }
        
        private void validate({ClassName}Req req) {
            // 参数校验逻辑
        }
        
        private {ClassName}Entity convertToEntity({ClassName}Req req) {
            return {ClassName}Entity.builder()
                .xxx(req.getXxx())
                .build();
        }
        
        private {ClassName}Resp convertToResp({ClassName}Entity entity) {
            return {ClassName}Resp.builder()
                .id(entity.getId())
                .xxx(entity.getXxx())
                .build();
        }
        
        private void updateEntity({ClassName}Entity entity, {ClassName}Req req) {
            entity.setXxx(req.getXxx());
        }
    }
    ```
  - **Controller 模板**：
    ```java
    @Tag(name = "{模块名}")
    @RestController
    @RequestMapping("/api/{module-name}")
    @RequiredArgsConstructor
    public class {ClassName}Controller {
        private final {ClassName}Service {className}Service;
        
        @Operation(summary = "根据ID查询")
        @GetMapping("/{id}")
        public Result<{ClassName}Resp> getById(@Parameter(description = "ID") @PathVariable Long id) {
            {ClassName}Resp resp = {className}Service.getById(id);
            return Result.success(resp);
        }
        
        @Operation(summary = "创建")
        @PostMapping
        public Result<Long> create(@RequestBody @Valid {ClassName}Req req) {
            Long id = {className}Service.create(req);
            return Result.success(id);
        }
        
        @Operation(summary = "修改")
        @PutMapping
        public Result<Void> update(@RequestBody @Valid {ClassName}Req req) {
            {className}Service.update(req);
            return Result.success();
        }
        
        @Operation(summary = "根据ID删除")
        @DeleteMapping("/{id}")
        public Result<Void> deleteById(@Parameter(description = "ID") @PathVariable Long id) {
            {className}Service.deleteById(id);
            return Result.success();
        }
        
        @Operation(summary = "分页查询")
        @GetMapping("/page")
        public Result<PageResult<{ClassName}Resp>> page(@ModelAttribute {ClassName}Query query) {
            PageResult<{ClassName}Resp> pageResult = {className}Service.page(query);
            return Result.success(pageResult);
        }
    }
    ```
  - **枚举模板**：
    ```java
    @Getter
    public enum {ClassName}Enum implements IEnum<Integer> {
        STATUS_1(1, "状态一"),
        STATUS_2(2, "状态二");
        
        private final Integer value;
        private final String desc;
        
        {ClassName}Enum(Integer value, String desc) {
            this.value = value;
            this.desc = desc;
        }
    }
    ```
  - **常量类模板**：
    ```java
    public class {ClassName}Const {
        public static final String KEY_PREFIX = "xxx:";
        public static final int DEFAULT_PAGE_SIZE = 10;
        public static final int MAX_PAGE_SIZE = 100;
    }
    ```
  - **异常类模板**：
    ```java
    @Data
    @AllArgsConstructor
    public class BusinessException extends RuntimeException {
        private Integer code;
        private String message;
    }
    ```

## 四、非功能需求
- **安全性**：
  - 验证码有效期5分钟，防止暴力破解
  - 用户认证使用JWT token，token有效期2小时
  - 敏感数据传输采用HTTPS加密
  - 数据库密码采用加密存储
  - 对应用户表的重要信息（如身份证/统一社会信用代码、联系人、手机号、邮箱）采用AES加密存储
- **性能要求**：
  - 页面加载时间≤2秒
  - API响应时间≤500ms
- **兼容性**：
  - 支持主流浏览器（Chrome、Firefox、Safari、Edge）
  - 适配1024px以上屏幕分辨率
- **可维护性**：
  - 代码模块化设计，便于扩展，模块之间解耦
- **用户体验**：
  - 界面简洁、操作 intuit ive
  - 提供清晰的错误提示和提示信息
