# 自动化部署流程规范

本文档旨在统一项目的自动化部署标准，确保后端（Java）与前端（Vue）项目发布的可靠性、一致性与可追溯性。所有生产环境的变更发布均需遵循此规范。

## 一、 后端部署规范 (Backend)

### 1. 环境与依赖
*   **运行环境**: CentOS 7+ / JDK 1.8+
*   **构建工具**: Maven 3.6+
*   **构建产物**: 可执行 JAR 包 (`*.jar`)

### 2. 构建流程 (Build)
1.  **代码检出**: 从 Git 仓库拉取指定分支（通常为 `master` 或 `release`）。
2.  **编译打包**:
    *   命令: `mvn clean package -DskipTests`
    *   **规范**: 禁止在生产构建中执行单元测试（应在 CI 阶段完成），以缩短发布窗口。
3.  **产物验证**:
    *   检查 `target/` 目录下是否生成 `jar` 文件。
    *   验证 JAR 包大小是否在合理范围内（避免依赖异常）。

### 3. 发布流程 (Deploy)
1.  **备份旧版本**:
    *   发布前**必须**备份当前运行的 JAR 包。
    *   命名规范: `{app-name}-{yyyyMMddHHmmss}.jar.bak`
2.  **优雅停机**:
    *   优先尝试 `kill -15` (SIGTERM)，等待应用释放资源。
    *   超时（如 30s）后强制 `kill -9`。
3.  **启动服务**:
    *   命令规范: 使用 `nohup` 后台启动，并指定 JVM 参数和配置文件。
    *   **关键参数**:
        *   `--spring.profiles.active=prod` (强制指定生产配置)
        *   `-Xms512m -Xmx1024m` (显式设置堆内存，防止 OOM)
        *   `--DB_PASSWORD=***` (敏感信息通过命令行参数或环境变量注入，禁止写死在配置文件)
4.  **健康检查 (Health Check)**:
    *   **日志检查**: 启动后 tail 日志，确认无 `ERROR` 且出现 `Started Application` 字样。
    *   **端口检查**: 确认 8080 端口处于 `LISTEN` 状态。
    *   **接口检查**: 调用 `/actuator/health` 或业务探针接口返回 200。

### 4. 自动化脚本支持 (Executable Specifications)

为确保 AI 和开发者能无歧义执行，提供标准的 Shell 脚本逻辑描述。

#### 4.1 后端部署脚本 (`scripts/deploy-backend.sh`)
*   **输入参数**:
    *   `ENV`: 环境名称 (prod/test)，必填。
*   **执行逻辑 (Pseudocode)**:
    ```bash
    #!/bin/bash
    
    # 1. 变量定义 (Configuration)
    APP_NAME="my-app"
    JAR_PATH="target/${APP_NAME}.jar"
    DEPLOY_DIR="/opt/apps/${APP_NAME}"
    BACKUP_DIR="${DEPLOY_DIR}/backup"
    PID_FILE="${DEPLOY_DIR}/app.pid"
    LOG_FILE="${DEPLOY_DIR}/logs/app.log"
    
    # 2. 检查环境 (Validation)
    if [ ! -f "$JAR_PATH" ]; then
        echo "Error: Build artifact not found at $JAR_PATH"
        exit 1
    fi
    
    # 3. 备份 (Backup)
    mkdir -p "$BACKUP_DIR"
    cp "${DEPLOY_DIR}/${APP_NAME}.jar" "${BACKUP_DIR}/${APP_NAME}-$(date +%Y%m%d%H%M%S).jar"
    
    # 4. 停机 (Stop)
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        kill -15 "$PID"
        # 等待 30s，每秒检查一次
        for i in {1..30}; do
            if ! ps -p "$PID" > /dev/null; then break; fi
            sleep 1
        done
        # 强制杀进程
        if ps -p "$PID" > /dev/null; then kill -9 "$PID"; fi
    fi
    
    # 5. 启动 (Start)
    cp "$JAR_PATH" "${DEPLOY_DIR}/${APP_NAME}.jar"
    nohup java -jar \
        -Dspring.profiles.active="$1" \
        -Xms512m -Xmx1024m \
        "${DEPLOY_DIR}/${APP_NAME}.jar" > "$LOG_FILE" 2>&1 &
    
    echo $! > "$PID_FILE"
    
    # 6. 健康检查 (Health Check)
    # 轮询 http://localhost:8080/actuator/health 直到返回 200 或超时
    ```

#### 4.2 前端部署脚本 (`scripts/deploy-frontend.sh`)
*   **核心特性**: 原子发布 (Atomic Deployment)
*   **执行逻辑 (Pseudocode)**:
    ```bash
    #!/bin/bash
    
    # 1. 变量定义
    DIST_SRC="dist"
    WEB_ROOT="/usr/share/nginx/html"
    RELEASE_DIR="${WEB_ROOT}/releases/$(date +%Y%m%d%H%M%S)"
    CURRENT_LINK="${WEB_ROOT}/current"
    
    # 2. 部署新版本 (Deploy)
    mkdir -p "$RELEASE_DIR"
    cp -r "${DIST_SRC}/"* "$RELEASE_DIR"
    
    # 3. 原子切换 (Switch)
    # ln -sfn: 强制更新符号链接
    ln -sfn "$RELEASE_DIR" "$CURRENT_LINK"
    
    # 4. 清理旧版本 (Cleanup)
    # 保留最近 5 个版本
    ls -dt "${WEB_ROOT}/releases/"* | tail -n +6 | xargs rm -rf
    
    # 5. 重载 Nginx (Reload)
    nginx -s reload
    ```

---

## 二、 前端部署规范 (Frontend)

### 1. 环境与依赖
*   **运行环境**: Nginx 1.16+
*   **构建工具**: Node.js 16+ / npm
*   **构建产物**: 静态资源目录 (`dist/`)

### 2. 构建流程 (Build)
1.  **依赖安装**:
    *   命令: `npm ci` (推荐) 或 `npm install`。
    *   **规范**: 使用 `npm ci` 锁定依赖版本（基于 `package-lock.json`），确保构建一致性。
2.  **代码构建**:
    *   命令: `npm run build`
    *   **环境变量**: 确保加载 `.env.production`，其中 `VITE_API_BASE_URL` 必须指向生产环境网关地址。
3.  **产物验证**:
    *   检查 `dist/index.html` 是否存在。
    *   检查 `dist/assets/` 下是否有指纹化的 JS/CSS 文件。

### 3. 发布流程 (Deploy)
1.  **静态资源同步**:
    *   **原子性发布**: 推荐先将新版上传至临时目录，再通过软链接切换或瞬间覆盖，避免发布期间出现 404。
    *   **目标路径**: `/usr/share/nginx/html` (示例)。
2.  **Nginx 配置**:
    *   **Gzip**: 必须开启 `gzip_static on;`，优先使用构建产出的 `.gz` 文件。
    *   **SPA 路由**: 必须配置 `try_files $uri $uri/ /index.html;`，防止刷新页面 404。
    *   **缓存策略**:
        *   `index.html`: `no-cache` (确保用户获取最新版本)。
        *   `assets/*.js|css`: `long-term cache` (利用文件名指纹缓存)。
3.  **服务重载**:
    *   命令: `nginx -t` (语法检查) -> `systemctl reload nginx` (平滑重载)。

### 4. 自动化脚本支持
提供实现 **原子发布 (Atomic Deployment)** 的脚本：
*   **脚本路径**: `scripts/deploy-frontend.sh`
*   **使用方法**:
    ```bash
    chmod +x scripts/deploy-frontend.sh
    ./scripts/deploy-frontend.sh prod
    ```
*   **功能**: 自动构建、生成版本号目录、切换软链接（0秒停机）、自动清理旧版本。

---

## 三、 回滚机制 (Rollback)

为确保 AI 和运维人员在紧急情况下能快速恢复服务，定义以下标准回滚操作。

### 1. 后端回滚脚本逻辑 (Pseudocode)
*   **脚本路径**: `scripts/rollback-backend.sh`
*   **逻辑**:
    ```bash
    # 1. 查找最近的备份文件
    LATEST_BACKUP=$(ls -t "${BACKUP_DIR}/"*.jar | head -n 1)
    
    if [ -z "$LATEST_BACKUP" ]; then
        echo "Error: No backup found!"
        exit 1
    fi
    
    # 2. 停止当前服务 (同部署脚本)
    ...
    
    # 3. 恢复备份
    cp "$LATEST_BACKUP" "${DEPLOY_DIR}/${APP_NAME}.jar"
    
    # 4. 启动服务 (同部署脚本)
    ...
    ```

### 2. 前端回滚脚本逻辑 (Pseudocode)
*   **脚本路径**: `scripts/rollback-frontend.sh`
*   **逻辑**:
    ```bash
    # 1. 查找上一个版本目录
    PREV_RELEASE=$(ls -dt "${WEB_ROOT}/releases/"* | head -n 2 | tail -n 1)
    
    # 2. 切换软链接
    ln -sfn "$PREV_RELEASE" "$CURRENT_LINK"
    
    # 3. 重载 Nginx
    nginx -s reload
    ```

---

## 四、 敏感信息管理

*   **原则**: 代码仓库中**严禁**包含生产环境的密码、密钥。
*   **实现**:
    *   **后端**: 数据库密码、JWT 密钥通过 Jenkins/GitLab CI 的 `Secrets` 注入，或在服务器启动脚本中通过环境变量设置。
    *   **前端**: 仅包含非敏感的公开配置（如 API Base URL）。
